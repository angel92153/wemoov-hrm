<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HRM Live (multi)</title>

  <style>
    @font-face { font-family:"StretchPro"; src:url("/static/fonts/StretchPro.otf") format("opentype"); font-display:swap; }
    @font-face { font-family:"Montserrat-Thin"; src:url("/static/fonts/Montserrat-Thin.ttf") format("truetype"); font-display:swap; }

    :root{
      --text:#ffffff; --bg:#000000; --z1:#3a3a3a; --z2:#1e3a8a; --z3:#166534; --z4:#7c3aed; --z5:#b91c1c;
      --font-nick:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-pct:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-metric:"Montserrat-Thin",system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;

      --fs-pct:8em; --fs-metric:4em; --fs-nick:8em; --icon-size:56px;

      --topbar-h: 76px;
      --phase-color: #eab308;
    }

    *{box-sizing:border-box}
    html,body{
      margin:0;height:100%;width:100%;
      background:var(--bg);color:var(--text);
      font-family:var(--font-metric);
      overflow:hidden;
    }

    header.topbar{
      position:fixed; inset:0 0 auto 0; height:var(--topbar-h);
      display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;
      padding: 0 16px; z-index:20;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .topbar .left{ justify-self:start; display:flex; align-items:center; gap: 0.25ch; white-space: nowrap; min-width: 0; }
    .topbar .center{ justify-self:center; height:100%; display:flex; align-items:center; }
    .topbar .right{ justify-self:end; display:flex; align-items:center; }

    .phase, .timer, .clock {
      font-family: "StretchPro", ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
      font-weight: 900; line-height: 1; letter-spacing: .03em; white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,.25);
      font-variant-numeric: tabular-nums;
      font-size: calc(var(--topbar-h) * 0.48);
    }
    .phase, .timer { color: var(--phase-color); }
    .clock { color: #ffffff; }

    .timer{ letter-spacing: 0; width: 4.5ch; flex: 0 0 4.5ch; text-align: left; margin: 0; }
    .invisible{ opacity: 0; }
    .phase{ overflow: hidden; text-overflow: ellipsis; max-width: 50vw; margin: 0; }

    .logo-img { display:block; height: calc(var(--topbar-h) * 0.5); max-width: 34vw; object-fit: contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }

    body{ display:flex;align-items:center;justify-content:center;padding:10px; padding-top:calc(var(--topbar-h) + 10px); }
    .wrap{width:100%;height:100%;max-width:1800px;display:flex;align-items:center;justify-content:center}
    .grid{display:grid;width:100%;height:100%;gap:14px;align-content:center;align-items:stretch;justify-content:center;transition:all .3s ease}

    .card{
      position:relative;border-radius:16px;padding:16px;
      box-shadow:0 10px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      transition:opacity .6s ease, transform .3s ease, box-shadow .3s ease;
      container-type:size;
      color:#fff;
      --base-nick:56px; --base-pct:64px; --base-metric:30px; --base-icon:30px;
      --fs-nick:max(var(--base-nick),10cqmin);
      --fs-pct:max(var(--base-pct),18cqmin);
      --fs-metric:max(var(--base-metric),7cqmin);
      --icon-size:max(var(--base-icon),5cqmin);
    }
    .card:active{transform:scale(.995)}
    .z1{background:var(--z1)}
    .z2{background:linear-gradient(135deg,#1e3a8a,#1f4bb5)}
    .z3{background:linear-gradient(135deg,#166534,#1c7a41)}
    .z4{background: linear-gradient(135deg, #7c3aed, #9333ea)}
    .z5{background:linear-gradient(135deg,#b91c1c,#ef4444)}

    .nick{ position:absolute; top:10px; left:50%; transform:translateX(-50%); font-family:var(--font-nick); font-weight:800; letter-spacing:.02em; font-size:var(--fs-nick); text-shadow:0 1px 2px rgba(0,0,0,.25); white-space:nowrap; }
    .pct{font-family:var(--font-pct);font-size:var(--fs-pct);font-weight:900;line-height:1;text-shadow:0 4px 10px rgba(0,0,0,.35);text-align:center}
    .metric{display:flex;align-items:center;gap:8px;font-family:var(--font-metric);font-size:var(--fs-metric);font-weight:800;text-shadow:0 1px 2px rgba(0,0,0,.25)}
    .metric .icon{display:inline-flex;width:var(--icon-size);height:var(--icon-size)}
    .metric .icon svg{width:100%;height:100%;fill:currentColor}
    .hr{position:absolute;bottom:10px;left:12px}
    .kcal{position:absolute;bottom:10px;left:50%;transform:translateX(-50%)}
    .moov{position:absolute;bottom:10px;right:12px}

    @keyframes thump{0%{transform:scale(1)}30%{transform:scale(1.15)}60%{transform:scale(1)}100%{transform:scale(1)}}
    .bump{animation:thump .18s ease-in-out}

    .empty{color:#9aa3b2;text-align:center;padding:24px;border:1px dashed #2c3350;border-radius:12px}
    @media (prefers-reduced-motion: reduce){.card,.grid{transition:none}.bump{animation:none}}
  </style>
</head>
<body>

  <header class="topbar">
    <div class="left">
      <div id="phaseTimer" class="timer invisible">00:00</div>
      <div id="phaseText" class="phase"></div>
    </div>
    <div class="center">
      <img src="/static/logo_wemoov.png" alt="WeMoov" class="logo-img" />
    </div>
    <div class="right">
      <div id="clock" class="clock">--:--:--</div>
    </div>
  </header>

  <div class="wrap"><div class="grid" id="grid"></div></div>

  <script>
    // ====== Reloj cabecera ======
    const clockEl = document.getElementById('clock');
    function updateClock(){
      const n=new Date(), hh=String(n.getHours()).padStart(2,'0'), mm=String(n.getMinutes()).padStart(2,'0'), ss=String(n.getSeconds()).padStart(2,'0');
      clockEl.textContent=`${hh}:${mm}:${ss}`;
    }
    setInterval(updateClock,1000); updateClock();

    // ====== Estado sesión (alias backend) ======
    const phaseEl = document.getElementById('phaseText');
    const timerEl = document.getElementById('phaseTimer');
    function fmtMMSS(sec){ sec=Math.max(0,Math.floor(sec)); return `${String(Math.floor(sec/60)).padStart(2,'0')}:${String(sec%60).padStart(2,'0')}`; }
    function setPhaseColor(hex){ document.documentElement.style.setProperty('--phase-color', hex||'#eab308'); }
    async function pollSession(){
      try{
        const res = await fetch('/session/status', { cache:'no-store' });
        const s = await res.json();
        if (!s.active && s.scheduled_ts){
          const cd = s.countdown_s || 0;
          if (s.show_countdown){
            setPhaseColor('#ffffff'); phaseEl.textContent = 'COUNTDOWN';
            timerEl.textContent = fmtMMSS(cd); timerEl.classList.remove('invisible');
          }else{
            setPhaseColor('#e7eaf3'); phaseEl.textContent = 'Sesión programada';
            timerEl.textContent = new Date(s.scheduled_ts*1000).toLocaleTimeString(); timerEl.classList.remove('invisible');
          }
          return;
        }
        if (s.active){
          setPhaseColor(s.phase_color||'#eab308');
          phaseEl.textContent = s.phase_key || 'Sesión';
          timerEl.textContent = fmtMMSS(s.phase_remaining_s ?? 0);
          timerEl.classList.remove('invisible');
          return;
        }
        setPhaseColor('#e7eaf3'); phaseEl.textContent = '';
        timerEl.textContent = '00:00'; timerEl.classList.add('invisible');
      }catch(e){}
    }
    setInterval(pollSession,1000); pollSession();

    // ====== HR Grid ======
    const POLL_MS = 1000, IDLE_POLL_MS = 5000, FETCH_TIMEOUT_MS = 8000, MAX_ERROR_BACKOFF_MS = 6000;
    const FADE_DURATION_MS = 60000, MIN_BEAT_MS = 900;
    const grid = document.getElementById('grid');
    const lastTs = new Map(), lastBeatAt = new Map(), cards = new Map();
    let nextTimer=null, errorBackoff=POLL_MS, abortCtrl=null, emptyMsgEl=null, beatIntervalId=null, useSSE=false, es=null;

    const zoneClass = z => ({ Z1:'z1', Z2:'z2', Z3:'z3', Z4:'z4', Z5:'z5' })[z] || 'z1';
    const pctFrom = (hr, hrmax) => (typeof hr==='number' && typeof hrmax==='number' && hrmax>0)
      ? Math.max(0, Math.min(100, Math.floor((hr*100)/hrmax))) : null;

    function layoutForCount(n){
      let cols=4, rows=1;
      if (n<=4){ cols=Math.max(1,n); rows=1; }
      else if (n<=8){ cols=4; rows=2; }
      else if (n<=12){ cols=4; rows=3; }
      else { cols=4; rows=4; }
      const vh = window.innerHeight - 30 - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h'));
      const heightPerCard = (vh - (rows - 1) * 14) / rows;
      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      grid.style.justifyContent = (n <= 4) ? 'center' : 'stretch';
      grid.querySelectorAll('.card').forEach(c => c.style.height = `${heightPerCard}px`);
    }

    function buildCard(d){
      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      const hr=(typeof d.hr==='number')?d.hr:null;
      const m=d.metrics||{}, hrmax=m.hr_max??null, zone=m.zone||'Z1';
      const pct=pctFrom(hr,hrmax);
      const kcal=(typeof m.kcal==='number')?m.kcal:null;
      const pts =(typeof m.points==='number')?m.points:null;

      const card=document.createElement('div');
      card.className=`card ${zoneClass(zone)}`; card.style.opacity='1';

      const nick = Object.assign(document.createElement('div'), { className:'nick', textContent:apodo });
      const pctEl= Object.assign(document.createElement('div'), { className:'pct',  textContent:(pct==null?'--%':`${pct}%`) });

      const hrWrap=Object.assign(document.createElement('div'), { className:'metric hr' });
      const hrEl  =Object.assign(document.createElement('span'), { id:`hr-${d.dev}`, textContent:(hr==null?'--':`${hr}`) });
      const heart =document.createElement('span'); heart.className='icon';
      heart.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 21s-5.052-3.247-8.106-6.3C1.84 12.646 1 10.97 1 9.2 1 6.88 2.88 5 5.2 5c1.36 0 2.656.56 3.6 1.56L12 9.04l3.2-2.48C16.144 5.56 17.44 5 18.8 5 21.12 5 23 6.88 23 9.2c0 1.77-.84 3.446-2.894 5.5C17.052 17.753 12 21 12 21z"/></svg>`;
      hrWrap.append(hrEl, heart);

      const kWrap =Object.assign(document.createElement('div'), { className:'metric kcal' });
      const kcalEl=Object.assign(document.createElement('span'), { id:`kcal-${d.dev}`, textContent:(kcal==null?'--':(Math.round(kcal*10)/10).toFixed(0)) });
      const flame =document.createElement('span'); flame.className='icon';
      flame.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 2C9.243 5.026 8 7.91 8 10.5A4.5 4.5 0 0 0 12.5 15c2.4 0 4.5-2 4.5-4.5 0-2.59-1.243-5.474-4-8.5zM12 22c5.523 0 10-4.477 10-10 0-4.004-2.383-7.738-6-9.334.666 1.944 1 3.994 1 6.334a6 6 0 1 1-12 0c0-2.34.334-4.39 1-6.334C4.383 4.262 2 7.996 2 12c0 5.523 4.477 10 10 10z"/></svg>`;
      kWrap.append(kcalEl, flame);

      const mWrap =Object.assign(document.createElement('div'), { className:'metric moov' });
      const moovEl=Object.assign(document.createElement('span'), { id:`moov-${d.dev}`, textContent:(pts==null?'--':(Math.round(pts*10)/10).toFixed(0)) });
      const mlogo =document.createElement('span'); mlogo.className='icon';
      mlogo.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"></circle><path d="M7 16V8h2.6l2.4 4 2.4-4H17v8h-2V11.7l-2 3.3h-2L9 11.7V16H7z" fill="var(--bg)"></path></svg>`;
      mWrap.append(moovEl, mlogo);

      card.append(nick, pctEl, hrWrap, kWrap, mWrap);
      return card;
    }

    function updateCardContent(card, d){
      const m=d.metrics||{}, zone=m.zone||'Z1';
      card.className = `card ${zoneClass(zone)}`;

      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      card.querySelector('.nick').textContent = apodo;

      const hr=(typeof d.hr==='number')?d.hr:null;
      const hrmax=m.hr_max??null;
      const pct=pctFrom(hr,hrmax);
      const pctEl = card.querySelector('.pct'); if (pctEl) pctEl.textContent = (pct==null?'--%':`${pct}%`);
      const hrEl = card.querySelector(`#hr-${d.dev}`); if (hrEl) hrEl.textContent = (hr==null?'--':`${hr}`);

      // NUEVO: actualizar kcal y puntos (si vienen en metrics)
      const kcal = (typeof m.kcal==='number') ? m.kcal : null;
      const pts  = (typeof m.points==='number') ? m.points : null;
      const kcalEl = card.querySelector(`#kcal-${d.dev}`);
      const ptsEl  = card.querySelector(`#moov-${d.dev}`);
      if (kcalEl) kcalEl.textContent = (kcal==null ? '--' : (Math.round(kcal*10)/10).toFixed(0));
      if (ptsEl)  ptsEl.textContent  = (pts ==null ? '--' : (Math.round(pts *10)/10).toFixed(0));
    }

    function reconcile(list){
      const now = Date.now();
      const arr = Array.isArray(list) ? list : [];
      const presentIds = new Set(arr.map(d => d.dev));

      // crear/actualizar
      arr.forEach(d => {
        let entry = cards.get(d.dev);
        if (!entry){
          const el = buildCard(d);
          cards.set(d.dev, { el, fadeStart: null });
          grid.append(el);
        }else{
          updateCardContent(entry.el, d);
          if (entry.fadeStart !== null){ entry.fadeStart = null; entry.el.style.opacity = '1'; }
        }
      });

      // desvanecer desaparecidos
      for (const [dev, entry] of Array.from(cards.entries())){
        if (!presentIds.has(dev)){
          if (entry.fadeStart == null){ entry.fadeStart = now; const hrEl = entry.el.querySelector(`#hr-${dev}`); if (hrEl) hrEl.classList.remove('bump'); }
          const p = Math.min(1, (now - entry.fadeStart) / FADE_DURATION_MS);
          entry.el.style.opacity = String(1 - p);
          if (p >= 1){ try { grid.removeChild(entry.el); } catch {} cards.delete(dev); lastTs.delete(dev); lastBeatAt.delete(dev); }
        }
      }

      const count = cards.size;
      if (emptyMsgEl) { try { grid.removeChild(emptyMsgEl); } catch {} emptyMsgEl = null; }
      if (count === 0){
        emptyMsgEl = document.createElement('div'); emptyMsgEl.className='empty'; emptyMsgEl.textContent='Sin dispositivos activos…'; grid.append(emptyMsgEl);
      }
      layoutForCount(count);

      // guardar ts (sin latir)
      arr.forEach(d=>{ const ts=d.ts||'', prev=lastTs.get(d.dev); if (ts && ts!==prev) lastTs.set(d.dev, ts); });
    }

    function bumpHR(devId){
      const entry = cards.get(devId);
      if (!entry || entry.fadeStart !== null) return;
      const now = performance.now(), last = lastBeatAt.get(devId) || 0;
      if (now - last < MIN_BEAT_MS) return;
      const el=document.getElementById(`hr-${devId}`); if (!el) return;
      el.classList.remove('bump'); void el.offsetWidth; el.classList.add('bump');
      lastBeatAt.set(devId, now);
    }

    function scheduleNext(ms){ if (nextTimer) clearTimeout(nextTimer); nextTimer = setTimeout(tick, ms); }
    function signature(list){ if (!Array.isArray(list)||!list.length) return '[]'; return list.map(d=>`${d.dev}|${d.hr}|${d.ts}`).join(','); }

    async function fetchOnceAndRender() {
      if (document.hidden){ scheduleNext(IDLE_POLL_MS); return; }
      if (abortCtrl) abortCtrl.abort();
      abortCtrl = new AbortController();
      const timeout = setTimeout(()=>abortCtrl.abort(), FETCH_TIMEOUT_MS);
      try{
        const res  = await fetch('/live?limit=16', { cache:'no-store', headers:{'Cache-Control':'no-store'}, signal:abortCtrl.signal });
        const list = await res.json();
        clearTimeout(timeout);

        reconcile(list);
        errorBackoff = POLL_MS;
        scheduleNext((list && list.length) ? POLL_MS : IDLE_POLL_MS);
      }catch(e){
        clearTimeout(timeout);
        errorBackoff = Math.min(MAX_ERROR_BACKOFF_MS, Math.max(POLL_MS, Math.floor((errorBackoff||POLL_MS)*2)));
        scheduleNext(errorBackoff);
      }
    }

    function tick(){ if (!useSSE) fetchOnceAndRender(); }

    // ====== SSE con fallback ======
    function startSSE() {
      try {
        es = new EventSource('/live/stream');
        useSSE = true;
        es.onmessage = (e) => { const list = JSON.parse(e.data); reconcile(list); };
        es.onerror = () => { if (es) { es.close(); es = null; } useSSE = false; tick(); };
      } catch (e) { useSSE = false; tick(); }
    }

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden){
        if (nextTimer) clearTimeout(nextTimer);
        if (!useSSE && !es) tick();
      }
    });

    window.addEventListener('resize', () => { layoutForCount(cards.size); });

    // LATIDO VISUAL
    if (beatIntervalId) clearInterval(beatIntervalId);
    beatIntervalId = setInterval(() => {
      if (document.hidden) return;
      for (const [dev, entry] of cards.entries()) { if (entry.fadeStart == null) bumpHR(dev); }
    }, 1000);

    // Arranque
    startSSE(); // intentamos stream; si falla, polling hará tick()
  </script>
</body>
</html>
