<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HRM Live (multi)</title>

  <style>
    /* ===========================
       Fuentes
       =========================== */
    @font-face { font-family:"StretchPro"; src:url("/static/fonts/StretchPro.otf") format("opentype"); font-display:swap; }
    @font-face { font-family:"Montserrat-Thin"; src:url("/static/fonts/Montserrat-Thin.ttf") format("truetype"); font-display:swap; }

:root{
  /* üé® Colores base */
  --text:#ffffff;
  --bg:#000000;
  --z1:#3a3a3a;
  --z2:#1e3a8a;
  --z3:#166534;
  --z4:#7c3aed;
  --z5:#b91c1c;

  /* üÖ∞Ô∏è Tipograf√≠as */
  --font-nick:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
  --font-pct:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
  --font-metric:"Montserrat-Thin",system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;

  /* üîù Topbar y fase */
  --topbar-h: 60px;
  --phase-color: #eab308;

  /* üî∂ Barra de zona superior */
  --zonebar-h: 14px;
  --zonebar-sep-color: #000000;
  --zonebar-sep-h: 2px;

  /* üß± M√°rgenes interiores del contenido central */
  --inner-side-gap: 6%;

  /* ============================================================
     üìè ESCALAS BASE (CASO 4√ó4)
     ============================================================ */
  --base-nick-16:   56px;  /* Nombre (arriba) */
  --base-pct-16:    56px;  /* % grande (centro) */
  --base-metric-16: 30px;  /* M√©tricas (abajo) */
  --base-icon-16:   30px;  /* Iconos m√©tricas */

  /* ============================================================
     üßÆ ESCALA GLOBAL (calculada din√°micamente por JS)
     ============================================================ */
  --text-scale: 1;

  /* üöÄ Boost de tama√±o para layouts 7‚Äì8 tarjetas */
  --size-boost: 1;          /* valor activo (lo setea JS) */
  --size-boost-7-8: 0.70;   /* cu√°nto quieres ampliar en 7 u 8 (aj√∫stalo a gusto) */

  /* Por si lo usas en otros sitios (opcional) */
  --nick-max-width: 92cqw;
}

    /* Reset y base */
    *{box-sizing:border-box}
    html,body{
      margin:0;height:100%;width:100%;
      background:var(--bg);color:var(--text);
      font-family:var(--font-metric);
      overflow:hidden;
    }

    /* ======= TOPBAR ESTABLE ======= */
    header.topbar{
      position:fixed; inset:0 0 auto 0; height:var(--topbar-h);
      display:grid;
      grid-template-columns: minmax(0,1fr) auto minmax(0,1fr);
      align-items:center; column-gap: 12px;
      padding: 0 12px 0 16px;
      z-index:20;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .topbar .left, .topbar .center, .topbar .right { position:relative; z-index:1; }
    .topbar .overlay { position:absolute; inset:0; pointer-events:none; z-index:2; }

    .clock, .phase, .timer{
      font-family:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      font-weight:900; line-height:1; letter-spacing:.02em; white-space:nowrap;
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      font-variant-numeric:tabular-nums;
      font-size: calc(var(--topbar-h) * 0.8);
    }
    .phase, .timer { color: var(--phase-color); }
    .clock { color:#fff; }

    .left{ display:flex; align-items:center; gap:12px; min-width:0; height:100%; }
    .timer{ width:6ch; text-align:left; }
    .center{ display:flex; align-items:center; justify-content:center; }
    .logo-img { display:block; height: calc(var(--topbar-h) * 0.5); max-width: 34vw; object-fit: contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }
    .right{ justify-self:end; }

    .phase{
      position:absolute; left:25%; top:50%; transform:translate(-50%, -50%);
      max-width:50vw; text-align:center; overflow:hidden; text-overflow:ellipsis; pointer-events:none;
    }

    .invisible{ opacity: 0; }

    /* ====== layout base ====== */
    .wrap { flex: 1; width: 100%; height: calc(100vh - var(--topbar-h)); margin-top: var(--topbar-h); display: flex; align-items: stretch; justify-content: stretch; }
    .grid { display: grid; width: 100%; height: 100%; gap: 14px; align-content: stretch; align-items: stretch; justify-content: stretch; transition: all .3s ease; }

    /* ====== Card ====== */
    .card{
      position:relative;border-radius:16px;padding:16px;
      box-shadow:0 10px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      transition:opacity .6s ease, transform .3s ease, box-shadow .3s ease;
      container-type:size; color:#fff;
    }
    .card:active{transform:scale(.995)}
    .z1{background:var(--z1)}
    .z2{background:linear-gradient(135deg,#1e3a8a,#1f4bb5)}
    .z3{background:linear-gradient(135deg,#166534,#1c7a41)}
    .z4{background:linear-gradient(135deg,#7c3aed,#9333ea)}
    .z5{background:linear-gradient(135deg,#b91c1c,#ef4444)}

    /* Barra de zona superior */
    .zonebar { position:absolute; inset:0 0 auto 0; height: var(--zonebar-h); width:100%; display:block; border-top-left-radius:16px; border-top-right-radius:16px; background:#000; opacity:1; z-index:3; pointer-events:none; }
    .zonebar::after { content:""; position:absolute; bottom:-var(--zonebar-sep-h); left:0; width:100%; height:var(--zonebar-sep-h); background: var(--zonebar-sep-color); border-bottom-left-radius:16px; border-bottom-right-radius:16px; z-index:4; }
    .zonebar.hidden { display:none; }

    /* ====== Nick (arriba) ====== */
    .nick{
      position:absolute;
      /* El top real lo calcula JS para centrar entre zonebar y %; fallback: */
      top: calc(var(--zonebar-h) + 8px);
      left:50%;
      transform: translateX(-50%);

      font-family:var(--font-nick);
      font-weight:800;
      letter-spacing:.02em;
      line-height:1.15; /* aire para descendentes */
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      text-align:center;

      /* Nunca partir en varias l√≠neas ni por palabras */
      white-space:nowrap;
      overflow-wrap: normal;
      word-break: keep-all;
      hyphens: none;

      max-width: var(--nick-max-width);

      font-size:clamp(
        10px,
        calc(var(--base-nick-16) * var(--text-scale)),
        20cqw
      );

      /* Ellipsis horizontal, descendentes visibles */
      overflow-x: clip;
      overflow-y: visible;
      text-overflow: ellipsis;

      /* opcional; puedes quitar si prefieres: */
      text-wrap: balance;
    }

    /* % central */
    .pct{
      font-family:var(--font-pct);
      font-weight:900;
      line-height:1;
      text-shadow:0 4px 10px rgba(0,0,0,.35);
      text-align:center;
      font-variant-numeric: tabular-nums;

      /* ‚úÖ base √ó escala √ó boost condicional (7‚Äì8) */
      font-size: calc(var(--base-pct-16) * var(--text-scale) * var(--size-boost));
    }

    /* M√©tricas inferior (HR/KCAL/MOOV) */
    .metric{
      display:flex; align-items:center; gap:8px;
      font-family:var(--font-metric); font-weight:800;
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      white-space:nowrap;
      line-height:1;

      /* ‚úÖ base √ó escala √ó boost condicional (7‚Äì8) */
      font-size: calc(var(--base-metric-16) * var(--text-scale) * var(--size-boost));
    }

    .metric .icon{ display:inline-flex; width: 1em; height: 1em; }
    .metric .icon svg{ width:100%; height:100%; fill:currentColor; }

    /* Slots inferiores: ancho fijo + ellipsis real */
    .hr, .kcal, .moov{
      position:absolute; bottom:10px;
      display: block;
      width: 30cqw;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .hr   { left:12px;  text-align:left; }
    .kcal { left:50%; transform:translateX(-50%); text-align:center; width:34cqw; }
    .moov { right:12px; text-align:right; }

    .pct.summary-host{display:flex;align-items:center;justify-content:center;padding:0 var(--inner-side-gap);} /* host limpio */

    /* === NUEVO: gr√°fica de resumen a pantalla (entre nick y m√©tricas) === */
    .summarybar{
      position:absolute;
      left: var(--inner-side-gap);
      right: var(--inner-side-gap);
      /* top y bottom los fija JS en tiempo real */
      display:block;
      border-radius:0;        /* sin redondeos */
      box-shadow:none;        /* sin bordes/sombras */
      background:transparent; /* solo la gr√°fica */
      pointer-events:none;
    }

    .empty{color:#9aa3b2;text-align:center;padding:24px;border:1px dashed #2c3350;border-radius:12px}
    @media (prefers-reduced-motion: reduce){.card,.grid{transition:none}}
  </style>
</head>
<body>

  <header class="topbar">
    <div class="left">
      <div id="phaseTimer" class="timer invisible">00:00</div>
    </div>
    <div class="center">
      <img src="/static/logo_wemoov.png" alt="WeMoov" class="logo-img" />
    </div>
    <div class="right">
      <div id="clock" class="clock">--:--</div>
    </div>

    <div class="overlay">
      <div id="phaseText" class="phase"></div>
    </div>
  </header>

  <div class="wrap"><div class="grid" id="grid"></div></div>

  <script>
    // ====== Config desde backend (unificado) ======
    let FADE_DURATION_MS = 60000;
    let LIVE_RECENT_MS = 5000;

    // ====== Resumen post-sesi√≥n ======
    let SUMMARY_MS = 15000;
    let SUMMARY_MODE = false;
    let SUMMARY_TIMER = null;
    let SUMMARY_LOADING = false;
    let LAST_SUMMARY_ETAG = null;
    const summaryBars = new Map();

    (async () => {
      try {
        const r = await fetch('/live/config', { cache: 'no-store' });
        if (r.ok) {
          const cfg = await r.json();
          if (cfg && typeof cfg.fade_ms === 'number') FADE_DURATION_MS = cfg.fade_ms;
          if (cfg && typeof cfg.recent_ms === 'number') LIVE_RECENT_MS = cfg.recent_ms;
          if (cfg && typeof cfg.summary_ms === 'number') SUMMARY_MS = cfg.summary_ms;
        }
      } catch {}
    })();

    // ====== Reloj cabecera ======
    const clockEl = document.getElementById('clock');
    function updateClock(){
      const n = new Date();
      const hh = String(n.getHours()).padStart(2,'0');
      const mm = String(n.getMinutes()).padStart(2,'0');
      clockEl.textContent = `${hh}:${mm}`;
      const msToNextMinute = (60 - n.getSeconds()) * 1000 - n.getMilliseconds();
      clearTimeout(updateClock._t);
      updateClock._t = setTimeout(updateClock, Math.max(0, msToNextMinute));
    }
    updateClock();

    // ====== Estado sesi√≥n ======
    const phaseEl = document.getElementById('phaseText');
    const timerEl = document.getElementById('phaseTimer');
    let SESSION_ACTIVE = false;
    let ZONELINE_TIMER = null;

    const ZONELINE_BUCKET_MS  = 5000;    // 5s
    const ZONELINE_WINDOW_MS  = 3600000; // 1h
    const ZONELINE_REFRESH_MS = 10000;   // 10s

    function fmtMMSS(sec){ sec=Math.max(0,Math.floor(sec)); return `${String(Math.floor(sec/60)).padStart(2,'0')}:${String(sec%60).padStart(2,'0')}`; }
    function setPhaseColor(hex){ document.documentElement.style.setProperty('--phase-color', hex||'#eab308'); }

    function ensureZoneLineTimer(on){
      for (const [, cnv] of zoneBars.entries()){
        if (!on) { clearCanvas(cnv); cnv.classList.add('hidden'); }
      }
      if (on && !ZONELINE_TIMER){ ZONELINE_TIMER = setInterval(refreshAllZoneBars, ZONELINE_REFRESH_MS); }
      if (!on && ZONELINE_TIMER){ clearInterval(ZONELINE_TIMER); ZONELINE_TIMER = null; }
    }

    function clearCanvas(cnv){
      const ctx = cnv.getContext('2d');
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = cnv.clientWidth  || cnv.parentElement?.clientWidth || 300;
      const heightCSS = cnv.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      cnv.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      cnv.height = Math.max(1, Math.floor(heightCSS * dpr));
      ctx.clearRect(0, 0, cnv.width, cnv.height);
    }

    function setZoneBarsVisible(on){
      for (const [, cnv] of zoneBars.entries()){
        if (on){
          // No desocultamos a ciegas; dejamos que drawZoneBarForDev decida
          drawZoneBarForDev(cnv.dataset.dev);
        } else {
          clearCanvas(cnv);
          cnv.classList.add('hidden');
        }
      }
    }

    // ====== Modo Resumen (solo /persisted) ======
    function renderReliefBar(canvas, timeline, bucket_ms){
      if (!Array.isArray(timeline) || timeline.length === 0) return;
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth || 420;
      const heightCSS = canvas.clientHeight || Math.max(120, (canvas.parentElement?.clientHeight || 200) * 0.6);
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.clearRect(0,0,canvas.width,canvas.height); // fondo limpio
      const firstT = timeline[0].t;
      const lastT  = (timeline[timeline.length - 1].t) + (bucket_ms || 1);
      const span   = Math.max(bucket_ms || 1, lastT - firstT);
      const toX = (t) => { const p = (t - firstT) / span; return Math.max(0, Math.min(canvas.width, Math.round(p * canvas.width))); };
      for (const b of timeline){
        const t0 = b.t, t1 = t0 + bucket_ms;
        const x0 = toX(t0), x1 = toX(t1);
        if (x1 <= 0 || x0 >= canvas.width) continue;
        const w = Math.max(1, x1 - x0);
        const frac = Math.max(0, Math.min(1, Number(b.frac) || 0));
        const h = Math.round(frac * canvas.height);
        const y = canvas.height - h;
        const z = b.zone_mode || 'Z1';
        ctx.fillStyle = zoneColor(z);
        ctx.fillRect(x0, y, w, h);
      }
    }

    // === NUEVO: posiciona el canvas de resumen para ocupar el hueco entre nick y m√©tricas ===
    function positionAndRenderSummaryBar(relief){
      if (!relief) return;
      const card = relief.closest('.card'); if (!card) return;

      const nickEl = card.querySelector('.nick');
      const hrEl   = card.querySelector('.hr'); // cualquiera de la l√≠nea de m√©tricas vale
      if (!nickEl || !hrEl) return;

      const topMargin    = 8; // margen entre nick y gr√°fica
      const bottomMargin = 8; // margen entre gr√°fica y m√©tricas

      const top = (nickEl.offsetTop + nickEl.offsetHeight + topMargin);
      const bottom = Math.max(bottomMargin, card.clientHeight - hrEl.offsetTop + 6);

      relief.style.top    = `${top}px`;
      relief.style.bottom = `${bottom}px`;

      const d = relief._summaryPayload || { timeline: [], bucket_ms: 5000 };
      renderReliefBar(relief, d.timeline, d.bucket_ms);
    }

    function buildSummaryCard(dev, apodo, metrics, timeline, bucket_ms){
      const d = {
        dev,
        user: { apodo },
        hr: null,
        metrics: { hr_max: null, zone: 'Z1', kcal: metrics?.kcal ?? null, points: metrics?.points ?? null }
      };

      const card = buildCard(d);

      // Oculta la zonebar en modo resumen
      const zc = zoneBars.get(dev);
      if (zc){ zc.classList.add('hidden'); clearCanvas(zc); }

      // Quitamos el % gigante del centro
      const pctEl = card.querySelector('.pct');
      if (pctEl){ pctEl.textContent = ''; }

      // ‚úÖ pinta % medio en HR (abajo izquierda)
      const pctAvg = Number(metrics?.pct_avg ?? NaN);
      const hrEl = card.querySelector(`#hr-${dev}`);
      if (hrEl){
        hrEl.textContent = Number.isFinite(pctAvg) ? `${Math.round(pctAvg)}%` : '--';
      }

      // Canvas de resumen ocupando el hueco entre nick y m√©tricas
      const relief = document.createElement('canvas');
      relief.className = 'summarybar';
      card.appendChild(relief);

      summaryBars.set(dev, relief);
      relief._summaryPayload = {
        timeline: Array.isArray(timeline) ? timeline : [],
        bucket_ms: bucket_ms || 5000
      };

      // Posicionar y dibujar ahora
      positionAndRenderSummaryBar(relief);

      return card;
    }

    function redrawAllSummaryBars(){
      for (const [dev, cnv] of summaryBars.entries()){
        positionAndRenderSummaryBar(cnv);
      }
    }

    async function getPersistedSummary(etag) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), 8000);
      try {
        const headers = {};
        if (etag) headers['If-None-Match'] = etag;
        const r = await fetch('/live/summary/persisted', { cache: 'no-store', headers, signal: ctrl.signal });
        clearTimeout(t);

        if (r.status === 204) {
          const ra = Number(r.headers.get('Retry-After') || 2);
          return { kind: 'pending', retryAfter: Number.isFinite(ra) ? ra : 2 };
        }
        if (r.status === 304) {
          return { kind: 'not_modified' };
        }
        if (r.ok) {
          const data = await r.json();
          let newETag = (r.headers.get('ETag') || '').replaceAll('"', '').trim() || null;
          return { kind: 'ok', data, etag: newETag };
        }
        return { kind: 'pending', retryAfter: 2 };
      } catch {
        clearTimeout(t);
        return { kind: 'pending', retryAfter: 2 };
      }
    }

    // ====== Helper para formatear el nick / ID sin saltos ======
    function formatNickText(apodo, dev){
      const t = (apodo ?? '').trim();
      if (!t) return `ID\u00A0${dev}`;                 // NBSP entre ID y n√∫mero
      if (/^ID\s+\S+$/i.test(t)) return t.replace(/\s+/, '\u00A0'); // tambi√©n si viene como "ID 123"
      return t;
    }

    async function startSummaryMode(){
      if (SUMMARY_MODE || SUMMARY_LOADING) return;
      SUMMARY_MODE = true;
      SUMMARY_LOADING = true;

      grid.innerHTML = '';
      cards.clear(); lastTs.clear(); lastBeatAt.clear();
      zoneBars.clear(); zoneBarState.clear(); summaryBars.clear();

      const holder = document.createElement('div');
      holder.className = 'card z1';
      holder.style.cssText = 'display:flex;align-items:center;justify-content:center;height:240px;opacity:1';
      holder.textContent = 'Generando resumen‚Ä¶';
      grid.appendChild(holder);
      layoutForCount(1);

      const T0 = Date.now();
      const MAX_WAIT = 12000;
      let payload = null;
      let etag = LAST_SUMMARY_ETAG || null;

      while ((Date.now() - T0) < MAX_WAIT && !SESSION_ACTIVE) {
        const res = await getPersistedSummary(etag);

        if (res.kind === 'ok') {
          payload = res.data;
          if (res.etag) etag = res.etag;
          break;
        }
        if (res.kind === 'not_modified') {
          if (!payload) {
            const res2 = await getPersistedSummary(null);
            if (res2.kind === 'ok') {
              payload = res2.data;
              if (res2.etag) etag = res2.etag;
            }
          }
          break;
        }
        const waitSec = Math.max(1, res.retryAfter || 2);
        await new Promise(r => setTimeout(r, waitSec * 1000));
      }

      if (SESSION_ACTIVE) {
        SUMMARY_LOADING = false;
        SUMMARY_MODE = false;
        grid.innerHTML = '';
        return;
      }

      if (!payload) {
        holder.textContent = 'Resumen no disponible a√∫n‚Ä¶';
        SUMMARY_LOADING = false;
        setTimeout(() => { if (!SESSION_ACTIVE) startSummaryMode(); }, 3000);
        return;
      }

      if (!Array.isArray(payload.devices) || payload.devices.length === 0){
        holder.textContent = 'Resumen vac√≠o.';
        SUMMARY_LOADING = false;
        return;
      }

      grid.innerHTML = '';
      cards.clear(); summaryBars.clear();

      const bucket = (typeof payload.bucket_ms === 'number') ? payload.bucket_ms : 5000;
      const devices = [...payload.devices].sort((a,b)=>{
        const da = (typeof a.dev === 'number') ? a.dev : String(a.dev);
        const db = (typeof b.dev === 'number') ? b.dev : String(b.dev);
        return (da>db)-(da<db);
      });

      try {
        for (const devRow of devices){
          const dev = devRow.dev;
          const apodo = (devRow.user && devRow.user.apodo) || `ID ${dev}`;
          const m = devRow.metrics || {};
          const tl = Array.isArray(devRow.timeline) ? devRow.timeline : [];
          const card = buildSummaryCard(dev, apodo, m, tl, bucket);
          grid.appendChild(card);
          cards.set(dev, { el: card, fadeStart: null });

          const nickEl = card.querySelector('.nick');
          if (nickEl) requestAnimationFrame(() => {
            fitNick(nickEl);
            placeNick(nickEl);
            positionAndRenderSummaryBar(summaryBars.get(dev));
          });
        }
      } catch (e) {
        console.error('render summary failed:', e);
        holder.textContent = 'Error renderizando el resumen';
        SUMMARY_LOADING = false;
        return;
      }

      layoutForCount(cards.size);
      if (etag) LAST_SUMMARY_ETAG = etag;
      SUMMARY_LOADING = false;
      stopSummaryMode(SUMMARY_MS);
    }

    function stopSummaryMode(delayMs){
      if (SUMMARY_TIMER) clearTimeout(SUMMARY_TIMER);
      SUMMARY_TIMER = setTimeout(() => {
        SUMMARY_MODE = false;
        grid.innerHTML = '';
        cards.clear(); lastTs.clear(); lastBeatAt.clear();
        zoneBars.clear(); zoneBarState.clear();
        summaryBars.clear();
      }, Math.max(0, Number(delayMs) || 0));
    }

    // ========= POLL de estado de sesi√≥n =========
    async function pollSession(){
      try{
        const res = await fetch('/control/status', { cache:'no-store' });
        const s = await res.json();
        const wasActive = SESSION_ACTIVE;
        SESSION_ACTIVE = !!s.active;

        if (!s.active && s.show_countdown){
          document.documentElement.style.setProperty('--phase-color', '#ffffff');
          timerEl.textContent = fmtMMSS(s.countdown_s || 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(false);
          setZoneBarsVisible(false);
          return;
        }

        if (s.active){
          setPhaseColor(s.phase_color||'#eab308');
          phaseEl.textContent = s.phase_key || 'Sesi√≥n';
          timerEl.textContent = fmtMMSS(s.phase_remaining_s ?? 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(true);
          if (!wasActive && SESSION_ACTIVE){
            setZoneBarsVisible(true);
            refreshAllZoneBars();
            if (SUMMARY_MODE) stopSummaryMode(0);
          }
          return;
        }

        // ‚¨áÔ∏è Sin sesi√≥n
        setPhaseColor('#e7eaf3');
        phaseEl.textContent = '';
        timerEl.textContent = '00:00';
        timerEl.classList.add('invisible');
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);

        if (wasActive && !SESSION_ACTIVE){ startSummaryMode(); }
      }catch(e){
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);
      }
    }
    setInterval(pollSession,1000); pollSession();

    // ====== HR Grid ======
    const POLL_MS = 1000, IDLE_POLL_MS = 5000, FETCH_TIMEOUT_MS = 8000, MAX_ERROR_BACKOFF_MS = 6000;
    const grid = document.getElementById('grid');
    const lastTs = new Map(), cards = new Map();
    const lastBeatAt = new Map();
    const zoneBars = new Map();
    const zoneBarState = new Map();
    let nextTimer=null, errorBackoff=POLL_MS, abortCtrl=null, useSSE=false, es=null;

    const zoneClass = z => ({ Z1:'z1', Z2:'z2', Z3:'z3', Z4:'z4', Z5:'z5' })[z] || 'z1';
    const zoneColor = z => ({
      Z1:getComputedStyle(document.documentElement).getPropertyValue('--z1').trim()||'#3a3a3a',
      Z2:getComputedStyle(document.documentElement).getPropertyValue('--z2').trim()||'#1e3a8a',
      Z3:getComputedStyle(document.documentElement).getPropertyValue('--z3').trim()||'#166534',
      Z4:getComputedStyle(document.documentElement).getPropertyValue('--z4').trim()||'#7c3aed',
      Z5:getComputedStyle(document.documentElement).getPropertyValue('--z5').trim()||'#b91c1c'
    })[z] || '#3a3a3a';
    const pctFrom = (hr, hrmax) => (typeof hr==='number' && typeof hrmax==='number' && hrmax>0)
      ? Math.max(0, Math.min(100, Math.floor((hr*100)/hrmax))) : null;

    /* ============================================================
       üìê C√°lculo de escala de texto (referencia 4x4)
       ============================================================ */
    function computeCardMinDim(cols, rows){
      const cs = getComputedStyle(grid);
      const rowGap = parseFloat(cs.rowGap || cs.gap) || 0;
      const colGap = parseFloat(cs.columnGap || cs.gap) || 0;

      const gridW = grid.clientWidth;
      const gridH = grid.clientHeight;

      const widthPerCard  = Math.max(0, (gridW - (cols - 1) * colGap) / cols);
      const heightPerCard = Math.max(0, (gridH - (rows - 1) * rowGap) / rows);
      return Math.min(widthPerCard, heightPerCard);
    }

    function getBaseMinDimFor16(){ return computeCardMinDim(4, 4); }

    function getCurrentMinDim(){
      const cols = (grid.style.gridTemplateColumns.match(/repeat\((\d+)/) || [ , 1 ])[1]*1 || 1;
      const rows = (grid.style.gridTemplateRows.match(/repeat\((\d+)/) || [ , 1 ])[1]*1 || 1;
      return computeCardMinDim(cols, rows);
    }

    function updateTextScale(){
      const baseMin = getBaseMinDimFor16();
      const curMin  = getCurrentMinDim();
      let scale = 1;
      if (baseMin > 0) scale = curMin / baseMin;
      document.documentElement.style.setProperty('--text-scale', String(scale));
    }

    /* ============================================================
       üî† Ajuste de nick (ancho) + üìç centrado vertical
       ============================================================ */
    function fitNick(el) {
      if (!el) return;
      const card = el.closest('.card');
      if (!card) return;

      // 1) ancho real permitido (max-width resuelto a px)
      const csEl = getComputedStyle(el);
      let maxW = parseFloat(csEl.maxWidth);
      if (!Number.isFinite(maxW) || maxW <= 0) {
        const csCard = getComputedStyle(card);
        const cardContentW =
          card.clientWidth -
          (parseFloat(csCard.paddingLeft) || 0) -
          (parseFloat(csCard.paddingRight) || 0);
        maxW = Math.max(0, cardContentW * 0.92);
      }

      // 2) l√≠mites por variables CSS
      const rootCss = getComputedStyle(document.documentElement);
      const baseNick = parseFloat(rootCss.getPropertyValue('--base-nick-16')) || 56;
      const scale    = parseFloat(rootCss.getPropertyValue('--text-scale')) || 1;
      const MIN_PX = 10;
      const MAX_PX = Math.max(MIN_PX, baseNick * scale);

      // 3) medir sin que el ellipsis enga√±e
      const prevOverflow = el.style.overflow;
      const prevTextOverflow = el.style.textOverflow;
      el.style.overflow = 'visible';
      el.style.textOverflow = 'clip';

      let lo = MIN_PX, hi = MAX_PX;
      el.style.fontSize = hi + 'px';
      if (el.scrollWidth > maxW) {
        for (let i = 0; i < 16; i++) {
          const mid = Math.floor((lo + hi) / 2);
          el.style.fontSize = mid + 'px';
          if (el.scrollWidth <= maxW) lo = mid; else hi = mid - 1;
        }
        el.style.fontSize = lo + 'px';
      }

      // 4) restaurar
      el.style.overflow = prevOverflow || 'clip';
      el.style.textOverflow = prevTextOverflow || 'ellipsis';
    }

    function placeNick(el) {
      if (!el) return;
      const card = el.closest('.card'); if (!card) return;
      const pctEl = card.querySelector('.pct');

      // desde arriba: borde inferior de la zonebar + margen base
      const zonebarH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      const topMargin = 8; // px extra sobre la zonebar
      const topY = zonebarH + topMargin;

      // hasta arriba del % (si no hay .pct a√∫n, usa ~45% de la card)
      let bottomY;
      if (pctEl) bottomY = pctEl.offsetTop;
      else bottomY = Math.round(card.clientHeight * 0.45);

      // altura del nick y hueco disponible
      const nickH = el.getBoundingClientRect().height || 0;
      const avail = Math.max(0, bottomY - topY);

      // centrado si cabe, si no, pegado al inicio del hueco
      const topPx = (nickH <= avail) ? (topY + Math.round((avail - nickH) / 2)) : topY;

      el.style.top = `${topPx}px`;
      el.style.transform = 'translateX(-50%)';
    }

    /* üéöÔ∏è Aplica boost de tama√±o solo en 7 u 8 cards */
    function applySizeBoost(n){
      const root = document.documentElement;
      const css = getComputedStyle(root);
      const boost78 = parseFloat(css.getPropertyValue('--size-boost-7-8')) || 1.25;
      const val = (n === 7 || n === 8) ? boost78 : 1;
      root.style.setProperty('--size-boost', String(val));
    }

    function layoutForCount(n){
      if (n <= 0){
        grid.style.gridTemplateColumns = '';
        grid.style.gridTemplateRows = '';
        grid.style.justifyContent = 'center';
        updateTextScale();
        grid.querySelectorAll('.nick').forEach(el => { fitNick(el); placeNick(el); });
        return;
      }

      let cols, rows;
      if (n <= 2){ cols = n; rows = 1; }
      else if (n <= 4){ cols = 2; rows = 2; }
      else if (n <= 6){ cols = 3; rows = 2; }
      else if (n <= 8){ cols = 4; rows = 2; }
      else if (n === 9){ cols = 3; rows = 3; }
      else if (n <= 12){ cols = 4; rows = 3; }
      else { cols = 4; rows = 4; }

      applySizeBoost(n);

      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows    = `repeat(${rows}, 1fr)`;
      grid.style.justifyContent      = 'stretch';
      grid.style.alignContent        = 'stretch';
      grid.style.alignItems          = 'stretch';

      const style = getComputedStyle(grid);
      const gap   = parseFloat(style.gap) || 0;
      const h     = grid.clientHeight;
      const heightPerCard = Math.max(0, (h - (rows - 1) * gap) / rows);

      grid.querySelectorAll('.card').forEach(c => { c.style.height = `${heightPerCard}px`; });

      updateTextScale();

      // Ajuste tras recalcular layout
      grid.querySelectorAll('.nick').forEach(el => { fitNick(el); placeNick(el); });

      // ‚úîÔ∏è Recolocar gr√°ficas tras cambio de layout
      redrawAllSummaryBars();
    }

    function buildCard(d){
      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      const hr=(typeof d.hr==='number')?d.hr:null;
      const m=d.metrics||{}, hrmax=m.hr_max??null, zone=m.zone||'Z1';
      const pct=pctFrom(hr,hrmax);
      const kcal=(typeof m.kcal==='number')?m.kcal:null;
      const pts =(typeof m.points==='number')?m.points:null;

      const card=document.createElement('div');
      card.className=`card ${zoneClass(zone)}`; card.style.opacity='1';

      const zc = document.createElement('canvas');
      zc.className = 'zonebar hidden';  // ‚¨ÖÔ∏è empieza oculta
      zc.dataset.dev = d.dev;
      card.appendChild(zc);
      zoneBars.set(d.dev, zc);

      const nickEl = Object.assign(document.createElement('div'), {
        className:'nick',
        textContent: formatNickText(apodo, d.dev)
      });
      const pctEl  = Object.assign(document.createElement('div'), {
        className:'pct',
        textContent:(pct==null?'--%':`${pct}%`)
      });

      const hrWrap=Object.assign(document.createElement('div'), { className:'metric hr' });
      const hrSpan=Object.assign(document.createElement('span'), { id:`hr-${d.dev}`, textContent:(hr==null?'--':`${hr}`) });
      const heart =document.createElement('span'); heart.className='icon';
      heart.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 21s-5.052-3.247-8.106-6.3C1.84 12.646 1 10.97 1 9.2 1 6.88 2.88 5 5.2 5c1.36 0 2.656.56 3.6 1.56L12 9.04l3.2-2.48C16.144 5.56 17.44 5 18.8 5 21.12 5 23 6.88 23 9.2c0 1.77-.84 3.446-2.894 5.5C17.052 17.753 12 21 12 21z"/></svg>`;
      hrWrap.append(hrSpan, heart);

      const kWrap =Object.assign(document.createElement('div'), { className:'metric kcal' });
      const kcalEl=Object.assign(document.createElement('span'), { id:`kcal-${d.dev}`, textContent:(kcal==null?'--':(Math.round(kcal*10)/10).toFixed(0)) });
      const flame =document.createElement('span'); flame.className='icon';
      flame.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 2C9.243 5.026 8 7.91 8 10.5A4.5 4.5 0 0 0 12.5 15c2.4 0 4.5-2 4.5-4.5 0-2.59-1.243-5.474-4-8.5zM12 22c5.523 0 10-4.477 10-10 0-4.004-2.383-7.738-6-9.334.666 1.944 1 3.994 1 6.334a6 6 0 1 1-12 0c0-2.34.334-4.39 1-6.334C4.383 4.262 2 7.996 2 12c0 5.523 4.477 10 10 10z"/></svg>`;
      kWrap.append(kcalEl, flame);

      const mWrap =Object.assign(document.createElement('div'), { className:'metric moov' });
      const moovEl=Object.assign(document.createElement('span'), { id:`moov-${d.dev}`, textContent:(pts==null?'--':(Math.round(pts*10)/10).toFixed(0)) });
      const mlogo =document.createElement('span'); mlogo.className='icon';
      mlogo.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"></circle><path d="M7 16V8h2.6l2.4 4 2.4-4H17v8h-2V11.7l-2 3.3h-2L9 11.7V16H7z" fill="var(--bg)"></path></svg>`;
      mWrap.append(moovEl, mlogo);

      card.append(nickEl, pctEl, hrWrap, kWrap, mWrap);

      if (SESSION_ACTIVE) drawZoneBarForDev(d.dev);

      requestAnimationFrame(() => { fitNick(nickEl); placeNick(nickEl); });

      return card;
    }

    function updateCardContent(card, d){
      const m=d.metrics||{}, zone=m.zone||'Z1';
      card.className = `card ${zoneClass(zone)}`;

      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      const nickEl = card.querySelector('.nick');
      if (nickEl) {
        const newTxt = formatNickText(apodo, d.dev);
        if (nickEl.textContent !== newTxt) nickEl.textContent = newTxt;
        requestAnimationFrame(() => { fitNick(nickEl); placeNick(nickEl); });
      }

      const hr=(typeof d.hr==='number')?d.hr:null;
      const hrmax=m.hr_max??null;
      const pct=pctFrom(hr,hrmax);
      const pctEl = card.querySelector('.pct'); if (pctEl) pctEl.textContent = (pct==null?'--%':`${pct}%`);
      const hrEl = card.querySelector(`#hr-${d.dev}`); if (hrEl) hrEl.textContent = (hr==null?'--':`${hr}`);

      const kcal = (typeof m.kcal==='number') ? m.kcal : null;
      const pts  = (typeof m.points==='number') ? m.points : null;
      const kcalEl = card.querySelector(`#kcal-${d.dev}`);
      const ptsEl  = card.querySelector(`#moov-${d.dev}`);
      if (kcalEl) kcalEl.textContent = (kcal==null ? '--' : (Math.round(kcal*10)/10).toFixed(0));
      if (ptsEl)  ptsEl.textContent  = (pts ==null ? '--' : (Math.round(pts *10)/10).toFixed(0));
    }

    function reconcile(list){
      if (SUMMARY_MODE) return;

      const now = Date.now();
      const arr = Array.isArray(list) ? list : [];
      const presentIds = new Set(arr.map(d => d.dev));

      arr.forEach(d => {
        let entry = cards.get(d.dev);
        if (!entry){
          const el = buildCard(d);
          cards.set(d.dev, { el, fadeStart: null });
          grid.append(el);
        }else{
          updateCardContent(entry.el, d);
          if (entry.fadeStart !== null){ entry.fadeStart = null; entry.el.style.opacity = '1'; }
        }
      });

      for (const [dev, entry] of Array.from(cards.entries())){
        if (!presentIds.has(dev)){
          if (entry.fadeStart == null){ entry.fadeStart = now; }
          const p = Math.min(1, (now - entry.fadeStart) / FADE_DURATION_MS);
          entry.el.style.opacity = String(1 - p);
          if (p >= 1){
            try { grid.removeChild(entry.el); } catch {}
            cards.delete(dev); lastTs.delete(dev);
            zoneBars.delete(dev); zoneBarState.delete(dev);
          }
        }
      }

      layoutForCount(cards.size);

      arr.forEach(d=>{ const ts=d.ts||'', prev=lastTs.get(d.dev); if (ts && ts!==prev) lastTs.set(d.dev, ts); });

      if (SESSION_ACTIVE){ arr.forEach(d => drawZoneBarForDev(d.dev)); }
    }

    function scheduleNext(ms){ if (nextTimer) clearTimeout(nextTimer); nextTimer = setTimeout(tick, ms); }

    // ====== Polling fallback ======
    const POLL_URL = '/live?limit=16';
    async function fetchOnceAndRender() {
      if (document.hidden){ scheduleNext(IDLE_POLL_MS); return; }
      if (abortCtrl) abortCtrl.abort();
      abortCtrl = new AbortController();
      const timeout = setTimeout(()=>abortCtrl.abort(), FETCH_TIMEOUT_MS);
      try{
        const res  = await fetch(POLL_URL, { cache:'no-store', headers:{'Cache-Control':'no-store'}, signal:abortCtrl.signal });
        const list = await res.json();
        clearTimeout(timeout);
        reconcile(list);
        errorBackoff = POLL_MS;
        scheduleNext((list && list.length) ? POLL_MS : IDLE_POLL_MS);
      }catch(e){
        clearTimeout(timeout);
        errorBackoff = Math.min(MAX_ERROR_BACKOFF_MS, Math.max(POLL_MS, Math.floor((errorBackoff||POLL_MS)*2)));
        scheduleNext(errorBackoff);
      }
    }
    function tick(){ if (!useSSE) fetchOnceAndRender(); }

    // ====== SSE con fallback ======
    function startSSE() {
      try {
        es = new EventSource('/live/stream');
        useSSE = true;
        es.onmessage = (e) => { const list = JSON.parse(e.data); reconcile(list); };
        es.onerror = () => { if (es) { es.close(); es = null; } useSSE = false; tick(); };
      } catch (e) { useSSE = false; tick(); }
    }

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden){
        if (nextTimer) clearTimeout(nextTimer);
        if (!useSSE && !es) tick();
        // ‚úîÔ∏è recolocar siempre las gr√°ficas al volver
        redrawAllSummaryBars();
        if (SUMMARY_MODE){ /* nada extra */ }
        else if (SESSION_ACTIVE){ refreshAllZoneBars(); }
        updateClock();
        updateTextScale();
        grid.querySelectorAll('.nick').forEach(el => { fitNick(el); placeNick(el); });
      }
    });

    window.addEventListener('resize', () => {
      layoutForCount(cards.size);
      // ‚úîÔ∏è recolocar siempre las gr√°ficas en resize
      redrawAllSummaryBars();
      if (SUMMARY_MODE){ /* nada extra */ }
      else if (SESSION_ACTIVE) { refreshAllZoneBars(); }
      updateTextScale();
      grid.querySelectorAll('.nick').forEach(el => { fitNick(el); placeNick(el); });
    });

    // ====== Zona timeline helpers ======
    async function drawZoneBarForDev(dev){
      const cardEntry = cards.get(dev); if (!cardEntry) return;
      const canvas = zoneBars.get(dev); if (!canvas) return;
      try{
        const url = `/live/zone_timeline?dev=${encodeURIComponent(dev)}&bucket_ms=${ZONELINE_BUCKET_MS}&window_ms=${ZONELINE_WINDOW_MS}`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) {
          clearCanvas(canvas);
          canvas.classList.add('hidden');
          return;
        }
        const data = await res.json();
        const ok = renderZoneBar(canvas, data);
        if (!ok) {
          clearCanvas(canvas);
          canvas.classList.add('hidden');
        } else {
          canvas.classList.remove('hidden');
        }
      }catch{
        clearCanvas(canvas);
        canvas.classList.add('hidden');
      }
    }

    function renderZoneBar(canvas, payload) {
      if (!payload || !Array.isArray(payload.timeline) || payload.timeline.length === 0) {
        clearCanvas(canvas);
        canvas.classList.add('hidden');   // ‚¨ÖÔ∏è sin datos ‚Üí oculta
        return false;
      }
      canvas.classList.remove('hidden');  // ‚¨ÖÔ∏è con datos ‚Üí muestra

      const { bucket_ms, timeline } = payload;
      const firstT = timeline[0].t;
      const lastT  = timeline[timeline.length - 1].t + bucket_ms;
      const span   = Math.max(bucket_ms || 1, lastT - firstT);
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth  || 300;
      const heightCSS = canvas.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));
      const ctx = canvas.getContext('2d');
      if (!ctx) return false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const toX = (t) => { const p = (t - firstT) / span; return Math.max(0, Math.min(canvas.width, p * canvas.width)); };
      const totalW = canvas.width;
      let prevRight = 0;
      for (let i = 0; i < timeline.length; i++) {
        const item = timeline[i];
        const t0 = item.t;
        const t1 = t0 + bucket_ms;
        const z  = item.zone_mode || 'Z1';
        const x0 = toX(t0);
        const x1 = toX(t1);
        const startX = Math.max(prevRight, Math.floor(x0));
        const segRight = Math.min(totalW, Math.ceil(x1));
        if (segRight > startX) {
          ctx.fillStyle = zoneColor(z);
          ctx.fillRect(startX, 0, segRight - startX + 1, canvas.height);
        }
        prevRight = segRight;
      }
      if (prevRight < totalW) { ctx.fillRect(totalW - 1, 0, 1, canvas.height); }
      return true;
    }

    function refreshAllZoneBars(){
      if (!SESSION_ACTIVE) return;
      for (const dev of cards.keys()){ drawZoneBarForDev(dev); }
    }

    // ‚úÖ Reajustar nicks cuando las webfonts est√©n listas
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        grid.querySelectorAll('.nick').forEach(el => { fitNick(el); placeNick(el); });
        // ‚úîÔ∏è recolocar gr√°ficas tras cambio de m√©tricas de texto
        redrawAllSummaryBars();
      });
    }

    // ====== Arranque ======
    startSSE(); // SSE; si falla, polling har√° tick()
  </script>
</body>
</html>
