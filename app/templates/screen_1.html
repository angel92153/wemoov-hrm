<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HRM Live (multi)</title>

  <style>
    @font-face { font-family:"StretchPro"; src:url("/static/fonts/StretchPro.otf") format("opentype"); font-display:swap; }
    @font-face { font-family:"Montserrat-Thin"; src:url("/static/fonts/Montserrat-Thin.ttf") format("truetype"); font-display:swap; }

    :root{
      --text:#ffffff; --bg:#000000;
      --z1:#3a3a3a; --z2:#1e3a8a; --z3:#166534; --z4:#7c3aed; --z5:#b91c1c;
      --font-nick:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-pct:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-metric:"Montserrat-Thin",system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;

      --fs-pct:8em; --fs-metric:4em; --fs-nick:8em; --icon-size:56px;

      --topbar-h: 76px;
      --phase-color: #eab308;

      /* grosor de la barra de zona */
      --zonebar-h: 14px;

      /* línea separadora */
      --zonebar-sep-color: #000000;
      --zonebar-sep-h: 2px;

      /* márgenes laterales del contenido central */
      --inner-side-gap: 6%;
    }

    *{box-sizing:border-box}
    html,body{
      margin:0;height:100%;width:100%;
      background:var(--bg);color:var(--text);
      font-family:var(--font-metric);
      overflow:hidden;
    }

    header.topbar{
      position:fixed; inset:0 0 auto 0; height:var(--topbar-h);
      display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;
      padding: 0 16px; z-index:20;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .topbar .left{ justify-self:start; display:flex; align-items:center; gap: 0.25ch; white-space: nowrap; min-width: 0; }
    .topbar .center{ justify-self:center; height:100%; display:flex; align-items:center; }
    .topbar .right {
      justify-self: end; display: flex; align-items: center;
      --clock-ch: 8; --clock-right-gap: 88px;
      width: calc(var(--clock-ch) * 1ch + var(--clock-right-gap));
      padding-right: var(--clock-right-gap);
      box-sizing: content-box;
    }
    .clock {
      display: block; width: calc(var(--clock-ch) * 1ch); text-align: left;
      font-family: "StretchPro", ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
      font-weight: 900; line-height: 1; letter-spacing: .03em; white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,.25); font-variant-numeric: tabular-nums;
      font-size: calc(var(--topbar-h) * 0.48); color: #ffffff;
    }

    .phase, .timer, .clock {
      font-family: "StretchPro", ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
      font-weight: 900; line-height: 1; letter-spacing: .03em; white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,.25); font-variant-numeric: tabular-nums;
      font-size: calc(var(--topbar-h) * 0.48);
    }
    .phase, .timer { color: var(--phase-color); }
    .clock { color: #ffffff; }

    .timer{ letter-spacing: 0; width: 4.5ch; flex: 0 0 4.5ch; text-align: left; margin: 0; }
    .invisible{ opacity: 0; }
    .phase{ overflow: hidden; text-overflow: ellipsis; max-width: 50vw; margin: 0; }

    .logo-img { display:block; height: calc(var(--topbar-h) * 0.5); max-width: 34vw; object-fit: contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }

    body{ display:flex;align-items:center;justify-content:center;padding:10px; padding-top:calc(var(--topbar-h) + 10px); }
    .wrap{width:100%;height:100%;max-width:1800px;display:flex;align-items:center;justify-content:center}
    .grid{display:grid;width:100%;height:100%;gap:14px;align-content:center;align-items:stretch;justify-content:center;transition:all .3s ease}

    .card{
      position:relative;border-radius:16px;padding:16px;
      box-shadow:0 10px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      transition:opacity .6s ease, transform .3s ease, box-shadow .3s ease;
      container-type:size;
      color:#fff;
      --base-nick:56px; --base-pct:56px; --base-metric:30px; --base-icon:30px;
      --fs-nick:max(var(--base-nick),10cqmin);
      --fs-pct: var(--fs-nick); /* ⬅️ el % escala igual que el nombre */
      --fs-metric:max(var(--base-metric),7cqmin);
      --icon-size:max(var(--base-icon),5cqmin);
    }
    .card:active{transform:scale(.995)}
    .z1{background:var(--z1)}
    .z2{background:linear-gradient(135deg,#1e3a8a,#1f4bb5)}
    .z3{background:linear-gradient(135deg,#166534,#1c7a41)}
    .z4{background: linear-gradient(135deg, #7c3aed, #9333ea)}
    .z5{background:linear-gradient(135deg,#b91c1c,#ef4444)}

    /* Barra de zona superior */
    .zonebar { position:absolute; inset:0 0 auto 0; height: var(--zonebar-h); width:100%; display:block; border-top-left-radius:16px; border-top-right-radius:16px; background:#000; opacity:1; z-index:3; pointer-events:none; }
    .zonebar::after { content:""; position:absolute; bottom:-var(--zonebar-sep-h); left:0; width:100%; height:var(--zonebar-sep-h); background: var(--zonebar-sep-color); border-bottom-left-radius:16px; border-bottom-right-radius:16px; z-index:4; }
    .zonebar.hidden { display:none; }

    .nick{ position:absolute; top:10px; left:50%; transform:translateX(-50%); font-family:var(--font-nick); font-weight:800; letter-spacing:.02em; font-size:var(--fs-nick); text-shadow:0 1px 2px rgba(0,0,0,.25); white-space:nowrap; }

    /* % grande sin cuadrado ni transiciones; escala como el nick */
    .pct{ font-family:var(--font-pct); font-size:var(--fs-pct); font-weight:900; line-height:1; text-shadow:0 4px 10px rgba(0,0,0,.35); text-align:center; font-variant-numeric: tabular-nums; }

    .metric{display:flex;align-items:center;gap:8px;font-family:var(--font-metric);font-size:var(--fs-metric);font-weight:800;text-shadow:0 1px 2px rgba(0,0,0,.25)}
    .metric .icon{display:inline-flex;width:var(--icon-size);height:var(--icon-size)}
    .metric .icon svg{width:100%;height:100%;fill:currentColor}
    .hr{position:absolute;bottom:10px;left:12px}
    .kcal{position:absolute;bottom:10px;left:50%;transform:translateX(-50%)}
    .moov{position:absolute;bottom:10px;right:12px}

    .summarybar{ box-shadow: inset 0 2px 8px rgba(0,0,0,.35), 0 10px 24px rgba(0,0,0,.25); border-radius: 10px; }

    .empty{color:#9aa3b2;text-align:center;padding:24px;border:1px dashed #2c3350;border-radius:12px}
    @media (prefers-reduced-motion: reduce){.card,.grid{transition:none}}
  </style>
</head>
<body>

  <header class="topbar">
    <div class="left">
      <div id="phaseTimer" class="timer invisible">00:00</div>
      <div id="phaseText" class="phase"></div>
    </div>
    <div class="center">
      <img src="/static/logo_wemoov.png" alt="WeMoov" class="logo-img" />
    </div>
    <div class="right">
      <div id="clock" class="clock">--:--:--</div>
    </div>
  </header>

  <div class="wrap"><div class="grid" id="grid"></div></div>

  <script>
    // ====== Config desde backend (unificado) ======
    let FADE_DURATION_MS = 60000;
    let LIVE_RECENT_MS = 5000;

    // ====== Resumen post-sesión ======
    let SUMMARY_MS = 15000;          // se sobreescribe desde /live/config
    let SUMMARY_MODE = false;        // bloquea reconcile() y muestra tarjetas de resumen
    let SUMMARY_TIMER = null;        // timeout para salir del modo resumen
    const summaryBars = new Map();   // dev -> canvas del relieve

    (async () => {
      try {
        const r = await fetch('/live/config', { cache: 'no-store' });
        if (r.ok) {
          const cfg = await r.json();
          if (cfg && typeof cfg.fade_ms === 'number') FADE_DURATION_MS = cfg.fade_ms;
          if (cfg && typeof cfg.recent_ms === 'number') LIVE_RECENT_MS = cfg.recent_ms;
          if (cfg && typeof cfg.summary_ms === 'number') SUMMARY_MS = cfg.summary_ms; // ⬅️ nuevo
        }
      } catch {}
    })();

    // ====== Reloj cabecera ======
    const clockEl = document.getElementById('clock');
    function updateClock(){
      const n=new Date(), hh=String(n.getHours()).padStart(2,'0'), mm=String(n.getMinutes()).padStart(2,'0'), ss=String(n.getSeconds()).padStart(2,'0');
      clockEl.textContent=`${hh}:${mm}:${ss}`;
    }
    setInterval(updateClock,1000); updateClock();

    // ====== Estado sesión ======
    const phaseEl = document.getElementById('phaseText');
    const timerEl = document.getElementById('phaseTimer');
    let SESSION_ACTIVE = false;
    let ZONELINE_TIMER = null;

    // Zona timeline params
    const ZONELINE_BUCKET_MS  = 5000;      // 5s
    const ZONELINE_WINDOW_MS  = 3600000;   // 1h (el backend limitará por KEEP_MS)
    const ZONELINE_REFRESH_MS = 10000;     // 10s

    function fmtMMSS(sec){ sec=Math.max(0,Math.floor(sec)); return `${String(Math.floor(sec/60)).padStart(2,'0')}:${String(sec%60).padStart(2,'0')}`; }
    function setPhaseColor(hex){ document.documentElement.style.setProperty('--phase-color', hex||'#eab308'); }

    function ensureZoneLineTimer(on){
      if (on && !ZONELINE_TIMER){
        ZONELINE_TIMER = setInterval(refreshAllZoneBars, ZONELINE_REFRESH_MS);
      }
      if (!on && ZONELINE_TIMER){
        clearInterval(ZONELINE_TIMER);
        ZONELINE_TIMER = null;
      }
    }

    // 🔧 utilidades para limpiar/ocultar/mostrar zonebars
    function clearCanvas(cnv){
      const ctx = cnv.getContext('2d');
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = cnv.clientWidth  || cnv.parentElement?.clientWidth || 300;
      const heightCSS = cnv.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      cnv.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      cnv.height = Math.max(1, Math.floor(heightCSS * dpr));
      ctx.clearRect(0, 0, cnv.width, cnv.height);
    }

    function setZoneBarsVisible(on){
      for (const [, cnv] of zoneBars.entries()){
        if (on){
          cnv.classList.remove('hidden');
          drawZoneBarForDev(cnv.dataset.dev);
        } else {
          clearCanvas(cnv);
          cnv.classList.add('hidden');
        }
      }
    }

    // ====== Modo Resumen ======
    function renderReliefBar(canvas, timeline, bucket_ms){
      if (!Array.isArray(timeline) || timeline.length === 0) return;

      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth || 420;
      const heightCSS = canvas.clientHeight || Math.max(120, (canvas.parentElement?.clientHeight || 200) * 0.6);
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));

      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const firstT = timeline[0].t;
      const lastT  = (timeline[timeline.length - 1].t) + (bucket_ms || 1);
      const span   = Math.max(bucket_ms || 1, lastT - firstT);

      const toX = (t) => {
        const p = (t - firstT) / span;
        return Math.max(0, Math.min(canvas.width, Math.round(p * canvas.width)));
      };

      for (const b of timeline){
        const t0 = b.t, t1 = t0 + bucket_ms;
        const x0 = toX(t0), x1 = toX(t1);
        if (x1 <= 0 || x0 >= canvas.width) continue;
        const w = Math.max(1, x1 - x0);

        const frac = Math.max(0, Math.min(1, Number(b.frac) || 0));
        const h = Math.round(frac * canvas.height);
        const y = canvas.height - h; // bajas abajo, altas arriba

        const z = b.zone_mode || 'Z1';
        ctx.fillStyle = zoneColor(z);
        ctx.fillRect(x0, y, w, h);
      }
    }

    function buildSummaryCard(dev, apodo, metrics, timeline, bucket_ms){
      // base card “vacía” con los totales
      const d = {
        dev,
        user: { apodo },
        hr: null,
        metrics: {
          hr_max: null,
          zone: 'Z1',
          kcal: metrics?.kcal ?? null,
          points: metrics?.points ?? null
        }
      };
      const card = buildCard(d);

      // Oculta barra superior y % central
      const zc = zoneBars.get(dev);
      if (zc){ zc.classList.add('hidden'); clearCanvas(zc); }

      const pctEl = card.querySelector('.pct');
      if (pctEl){ pctEl.textContent = ''; }

      // Sustituye bpm por %HRmax medio
      const pctAvg = Number(metrics?.pct_avg ?? 0);
      const hrEl = card.querySelector(`#hr-${dev}`);
      if (hrEl){ hrEl.textContent = `${Math.round(pctAvg)}%`; }

      // Canvas central con relieve
      const relief = document.createElement('canvas');
      relief.className = 'summarybar';
      relief.style.position = 'absolute';
      relief.style.left = '6%';
      relief.style.right = '6%';
      relief.style.opacity = '0.95';
      relief.style.borderRadius = '10px';

      card.appendChild(relief);
      summaryBars.set(dev, relief);

      // Guardamos payload para repintar en resize
      relief._summaryPayload = { timeline: Array.isArray(timeline) ? timeline : [], bucket_ms: bucket_ms || 5000 };
      renderReliefBar(relief, relief._summaryPayload.timeline, relief._summaryPayload.bucket_ms);

      layoutSummaryCanvasForCard(card, relief);

      return card;
    }

    function redrawAllSummaryBars(){
      for (const [dev, cnv] of summaryBars.entries()){
        const data = cnv._summaryPayload;
        if (data){
          renderReliefBar(cnv, data.timeline || [], data.bucket_ms || 5000);
        }
      }
    }

    async function startSummaryMode(){
      if (SUMMARY_MODE) return;
      SUMMARY_MODE = true;

      // Pedimos el resumen al backend
      let data = null;
      try{
        const r = await fetch('/live/summary?bucket_ms=5000', { cache:'no-store' });
        data = r.ok ? await r.json() : null;
      }catch{}

      // Limpiamos grid y estados
      grid.innerHTML = '';
      cards.clear(); lastTs.clear(); lastBeatAt.clear();
      zoneBars.clear(); zoneBarState.clear();
      summaryBars.clear();

      if (!data || !Array.isArray(data.devices) || data.devices.length === 0){
        stopSummaryMode(0);
        return;
      }

      // Construye tarjetas de resumen
      for (const devRow of data.devices){
        const dev = devRow.dev;
        const apodo = (devRow.user && devRow.user.apodo) || `ID ${dev}`;
        const m = devRow.metrics || {};
        const tl = Array.isArray(devRow.timeline) ? devRow.timeline : [];
        const card = buildSummaryCard(dev, apodo, m, tl, 5000);
        grid.appendChild(card);
        cards.set(dev, { el: card, fadeStart: null });
      }

      layoutForCount(cards.size);
      stopSummaryMode(SUMMARY_MS);
    }

    function stopSummaryMode(delayMs){
      if (SUMMARY_TIMER) clearTimeout(SUMMARY_TIMER);
      SUMMARY_TIMER = setTimeout(() => {
        SUMMARY_MODE = false;
        grid.innerHTML = '';
        cards.clear(); lastTs.clear(); lastBeatAt.clear();
        zoneBars.clear(); zoneBarState.clear();
        summaryBars.clear();
      }, Math.max(0, Number(delayMs) || 0));
    }

    // ========= POLL de estado de sesión =========
    async function pollSession(){
      try{
        const res = await fetch('/control/status', { cache:'no-store' });
        const s = await res.json();
        const wasActive = SESSION_ACTIVE;
        SESSION_ACTIVE = !!s.active;

        if (!s.active && s.show_countdown){
          document.documentElement.style.setProperty('--phase-color', '#ffffff');
          const pausedSuffix = (s.countdown_paused ? ' · PAUSA' : '');
          phaseEl.textContent = 'COUNTDOWN' + pausedSuffix;
          timerEl.textContent = fmtMMSS(s.countdown_s || 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(false);
          setZoneBarsVisible(false);
          return;
        }

        if (s.active){
          setPhaseColor(s.phase_color||'#eab308');
          phaseEl.textContent = s.phase_key || 'Sesión';
          timerEl.textContent = fmtMMSS(s.phase_remaining_s ?? 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(true);
          if (!wasActive && SESSION_ACTIVE){
            setZoneBarsVisible(true);
            refreshAllZoneBars();
            if (SUMMARY_MODE) stopSummaryMode(0); // si veníamos de resumen, lo quitamos
          }
          return;
        }

        // ⬇️ Sin sesión
        setPhaseColor('#e7eaf3');
        phaseEl.textContent = '';
        timerEl.textContent = '00:00';
        timerEl.classList.add('invisible');
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);

        // Transición de activa -> inactiva: arrancar resumen
        if (wasActive && !SESSION_ACTIVE){
          startSummaryMode();
        }
      }catch(e){
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);
      }
    }
    setInterval(pollSession,1000); pollSession();

    // ====== HR Grid ======
    const POLL_MS = 1000, IDLE_POLL_MS = 5000, FETCH_TIMEOUT_MS = 8000, MAX_ERROR_BACKOFF_MS = 6000;
    const grid = document.getElementById('grid');
    const lastTs = new Map(), cards = new Map();
    const zoneBars = new Map();      // dev -> canvas (barra superior)
    const zoneBarState = new Map();  // dev -> { lastAnchor, lastLen }
    let nextTimer=null, errorBackoff=POLL_MS, abortCtrl=null, useSSE=false, es=null;

    const zoneClass = z => ({ Z1:'z1', Z2:'z2', Z3:'z3', Z4:'z4', Z5:'z5' })[z] || 'z1';
    const zoneColor = z => ({
      Z1:getComputedStyle(document.documentElement).getPropertyValue('--z1').trim()||'#3a3a3a',
      Z2:getComputedStyle(document.documentElement).getPropertyValue('--z2').trim()||'#1e3a8a',
      Z3:getComputedStyle(document.documentElement).getPropertyValue('--z3').trim()||'#166534',
      Z4:getComputedStyle(document.documentElement).getPropertyValue('--z4').trim()||'#7c3aed',
      Z5:getComputedStyle(document.documentElement).getPropertyValue('--z5').trim()||'#b91c1c'
    })[z] || '#3a3a3a';
    const pctFrom = (hr, hrmax) => (typeof hr==='number' && typeof hrmax==='number' && hrmax>0)
      ? Math.max(0, Math.min(100, Math.floor((hr*100)/hrmax))) : null;

    function layoutForCount(n){
      if (n <= 0){
        grid.style.gridTemplateColumns = '';
        grid.style.gridTemplateRows = '';
        grid.style.justifyContent = 'center';
        return;
      }
      let cols=4, rows=1;
      if (n<=4){ cols=Math.max(1,n); rows=1; }
      else if (n<=8){ cols=4; rows=2; }
      else if (n<=12){ cols=4; rows=3; }
      else { cols=4; rows=4; }
      const vh = window.innerHeight - 30 - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h'));
      const heightPerCard = (vh - (rows - 1) * 14) / rows;
      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      grid.style.justifyContent = (n <= 4) ? 'center' : 'stretch';
      grid.querySelectorAll('.card').forEach(c => c.style.height = `${heightPerCard}px`);
    }

    function buildCard(d){
      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      const hr=(typeof d.hr==='number')?d.hr:null;
      const m=d.metrics||{}, hrmax=m.hr_max??null, zone=m.zone||'Z1';
      const pct=pctFrom(hr,hrmax);
      const kcal=(typeof m.kcal==='number')?m.kcal:null;
      const pts =(typeof m.points==='number')?m.points:null;

      const card=document.createElement('div');
      card.className=`card ${zoneClass(zone)}`; card.style.opacity='1';

      // barra superior (zona)
      const zc = document.createElement('canvas');
      zc.className = 'zonebar';
      zc.dataset.dev = d.dev;
      if (!SESSION_ACTIVE) zc.classList.add('hidden');
      card.appendChild(zc);
      zoneBars.set(d.dev, zc);

      const nick = Object.assign(document.createElement('div'), { className:'nick', textContent:apodo });
      const pctEl= Object.assign(document.createElement('div'), { className:'pct',  textContent:(pct==null?'--%':`${pct}%`) });

      const hrWrap=Object.assign(document.createElement('div'), { className:'metric hr' });
      const hrEl  =Object.assign(document.createElement('span'), { id:`hr-${d.dev}`, textContent:(hr==null?'--':`${hr}`) });
      const heart =document.createElement('span'); heart.className='icon';
      heart.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 21s-5.052-3.247-8.106-6.3C1.84 12.646 1 10.97 1 9.2 1 6.88 2.88 5 5.2 5c1.36 0 2.656.56 3.6 1.56L12 9.04l3.2-2.48C16.144 5.56 17.44 5 18.8 5 21.12 5 23 6.88 23 9.2c0 1.77-.84 3.446-2.894 5.5C17.052 17.753 12 21 12 21z"/></svg>`;
      hrWrap.append(hrEl, heart);

      const kWrap =Object.assign(document.createElement('div'), { className:'metric kcal' });
      const kcalEl=Object.assign(document.createElement('span'), { id:`kcal-${d.dev}`, textContent:(kcal==null?'--':(Math.round(kcal*10)/10).toFixed(0)) });
      const flame =document.createElement('span'); flame.className='icon';
      flame.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 2C9.243 5.026 8 7.91 8 10.5A4.5 4.5 0 0 0 12.5 15c2.4 0 4.5-2 4.5-4.5 0-2.59-1.243-5.474-4-8.5zM12 22c5.523 0 10-4.477 10-10 0-4.004-2.383-7.738-6-9.334.666 1.944 1 3.994 1 6.334a6 6 0 1 1-12 0c0-2.34.334-4.39 1-6.334C4.383 4.262 2 7.996 2 12c0 5.523 4.477 10 10 10z"/></svg>`;
      kWrap.append(kcalEl, flame);

      const mWrap =Object.assign(document.createElement('div'), { className:'metric moov' });
      const moovEl=Object.assign(document.createElement('span'), { id:`moov-${d.dev}`, textContent:(pts==null?'--':(Math.round(pts*10)/10).toFixed(0)) });
      const mlogo =document.createElement('span'); mlogo.className='icon';
      mlogo.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"></circle><path d="M7 16V8h2.6l2.4 4 2.4-4H17v8h-2V11.7l-2 3.3h-2L9 11.7V16H7z" fill="var(--bg)"></path></svg>`;
      mWrap.append(moovEl, mlogo);

      card.append(nick, pctEl, hrWrap, kWrap, mWrap);

      if (SESSION_ACTIVE) drawZoneBarForDev(d.dev);
      return card;
    }

    function updateCardContent(card, d){
      const m=d.metrics||{}, zone=m.zone||'Z1';
      card.className = `card ${zoneClass(zone)}`;

      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      card.querySelector('.nick').textContent = apodo;

      const hr=(typeof d.hr==='number')?d.hr:null;
      const hrmax=m.hr_max??null;
      const pct=pctFrom(hr,hrmax);
      const pctEl = card.querySelector('.pct'); if (pctEl) pctEl.textContent = (pct==null?'--%':`${pct}%`);
      const hrEl = card.querySelector(`#hr-${d.dev}`); if (hrEl) hrEl.textContent = (hr==null?'--':`${hr}`);

      const kcal = (typeof m.kcal==='number') ? m.kcal : null;
      const pts  = (typeof m.points==='number') ? m.points : null;
      const kcalEl = card.querySelector(`#kcal-${d.dev}`);
      const ptsEl  = card.querySelector(`#moov-${d.dev}`);
      if (kcalEl) kcalEl.textContent = (kcal==null ? '--' : (Math.round(kcal*10)/10).toFixed(0));
      if (ptsEl)  ptsEl.textContent  = (pts ==null ? '--' : (Math.round(pts *10)/10).toFixed(0));
    }

    function reconcile(list){
      if (SUMMARY_MODE) return; // no tocar tarjetas durante el modo resumen

      const now = Date.now();
      const arr = Array.isArray(list) ? list : [];
      const presentIds = new Set(arr.map(d => d.dev));

      // crear/actualizar
      arr.forEach(d => {
        let entry = cards.get(d.dev);
        if (!entry){
          const el = buildCard(d);
          cards.set(d.dev, { el, fadeStart: null });
          grid.append(el);
        }else{
          updateCardContent(entry.el, d);
          if (entry.fadeStart !== null){ entry.fadeStart = null; entry.el.style.opacity = '1'; }
        }
      });

      // desvanecer desaparecidos
      for (const [dev, entry] of Array.from(cards.entries())){
        if (!presentIds.has(dev)){
          if (entry.fadeStart == null){
            entry.fadeStart = now;
          }
          const p = Math.min(1, (now - entry.fadeStart) / FADE_DURATION_MS);
          entry.el.style.opacity = String(1 - p);
          if (p >= 1){
            try { grid.removeChild(entry.el); } catch {}
            cards.delete(dev); lastTs.delete(dev);
            zoneBars.delete(dev); zoneBarState.delete(dev);
          }
        }
      }

      const count = cards.size;
      layoutForCount(count);

      // guardar ts
      arr.forEach(d=>{ const ts=d.ts||'', prev=lastTs.get(d.dev); if (ts && ts!==prev) lastTs.set(d.dev, ts); });

      // si hay sesión activa, refrescamos zona del recién llegado
      if (SESSION_ACTIVE){
        arr.forEach(d => drawZoneBarForDev(d.dev));
      }
    }

    function scheduleNext(ms){ if (nextTimer) clearTimeout(nextTimer); nextTimer = setTimeout(tick, ms); }
    function signature(list){ if (!Array.isArray(list)||!list.length) return '[]'; return list.map(d=>`${d.dev}|${d.hr}|${d.ts}`).join(','); }

    // ====== Polling fallback ======
    const POLL_URL = '/live?limit=16';
    async function fetchOnceAndRender() {
      if (document.hidden){ scheduleNext(IDLE_POLL_MS); return; }
      if (abortCtrl) abortCtrl.abort();
      abortCtrl = new AbortController();
      const timeout = setTimeout(()=>abortCtrl.abort(), FETCH_TIMEOUT_MS);
      try{
        const res  = await fetch(POLL_URL, { cache:'no-store', headers:{'Cache-Control':'no-store'}, signal:abortCtrl.signal });
        const list = await res.json();
        clearTimeout(timeout);

        reconcile(list);
        errorBackoff = POLL_MS;
        scheduleNext((list && list.length) ? POLL_MS : IDLE_POLL_MS);
      }catch(e){
        clearTimeout(timeout);
        errorBackoff = Math.min(MAX_ERROR_BACKOFF_MS, Math.max(POLL_MS, Math.floor((errorBackoff||POLL_MS)*2)));
        scheduleNext(errorBackoff);
      }
    }
    function tick(){ if (!useSSE) fetchOnceAndRender(); }

    // ====== SSE con fallback ======
    function startSSE() {
      try {
        es = new EventSource('/live/stream');
        useSSE = true;
        es.onmessage = (e) => { const list = JSON.parse(e.data); reconcile(list); };
        es.onerror = () => { if (es) { es.close(); es = null; } useSSE = false; tick(); };
      } catch (e) { useSSE = false; tick(); }
    }

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden){
        if (nextTimer) clearTimeout(nextTimer);
        if (!useSSE && !es) tick();
        if (SUMMARY_MODE){
          redrawAllSummaryBars();
        }else if (SESSION_ACTIVE){
          refreshAllZoneBars();
        }
      }
    });
    window.addEventListener('resize', () => {
      layoutForCount(cards.size);
      if (SUMMARY_MODE){
        redrawAllSummaryBars();
      } else if (SESSION_ACTIVE) {
        refreshAllZoneBars(); // re-render para ajustar anchuras
      }
    });

    // ====== Zona timeline helpers (ANCLADO AL INICIO) ======
    async function drawZoneBarForDev(dev){
      const cardEntry = cards.get(dev); if (!cardEntry) return;
      const canvas = zoneBars.get(dev); if (!canvas) return;

      try{
        const url = `/live/zone_timeline?dev=${encodeURIComponent(dev)}&bucket_ms=${ZONELINE_BUCKET_MS}&window_ms=${ZONELINE_WINDOW_MS}`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        renderZoneBar(canvas, data);
      }catch{}
    }

    function renderZoneBar(canvas, payload) {
      if (!payload || !Array.isArray(payload.timeline) || payload.timeline.length === 0) return;
      const { bucket_ms, timeline } = payload;

      // Anclamos al primer bucket y extendemos hasta el final del último
      const firstT = timeline[0].t;
      const lastT  = timeline[timeline.length - 1].t + bucket_ms;
      const span   = Math.max(bucket_ms || 1, lastT - firstT);

      // DPR y tamaño canvas
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth  || 300;
      const heightCSS = canvas.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Fondo negro opaco (para cubrir degradado de la tarjeta)
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Mapeo tiempo → coordenada X
      const toX = (t) => {
        const p = (t - firstT) / span;
        return Math.max(0, Math.min(canvas.width, p * canvas.width));
      };

      // ---- Pintado continuo (sin huecos por redondeo) ----
      const totalW = canvas.width;
      let prevRight = 0;

      for (let i = 0; i < timeline.length; i++) {
        const item = timeline[i];
        const t0 = item.t;
        const t1 = t0 + bucket_ms;
        const z  = item.zone_mode || 'Z1';

        // Borde izquierdo y derecho del bucket
        const x0 = toX(t0);
        const x1 = toX(t1);

        // Redondeo estable y continuidad
        const startX = Math.max(prevRight, Math.floor(x0));
        const segRight = Math.min(totalW, Math.ceil(x1));

        // Si hay hueco real entre buckets (datos faltantes), lo dejamos negro
        if (segRight > startX) {
          ctx.fillStyle = zoneColor(z);
          ctx.fillRect(startX, 0, segRight - startX + 1, canvas.height);
        }

        prevRight = segRight;
      }

      // Asegura cubrir el último píxel si quedó 1px de margen
      if (prevRight < totalW) {
        ctx.fillRect(totalW - 1, 0, 1, canvas.height);
      }
    }

    function refreshAllZoneBars(){
      if (!SESSION_ACTIVE) return;
      for (const dev of cards.keys()){
        drawZoneBarForDev(dev);
      }
    }

    // ====== Arranque ======
    startSSE(); // intentamos stream; si falla, polling hará tick()
  </script>
</body>
</html>