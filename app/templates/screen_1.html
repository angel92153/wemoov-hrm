<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HRM Live (multi)</title>

  <style>
    @font-face { font-family:"StretchPro"; src:url("/static/fonts/StretchPro.otf") format("opentype"); font-display:swap; }
    @font-face { font-family:"Montserrat-Thin"; src:url("/static/fonts/Montserrat-Thin.ttf") format("truetype"); font-display:swap; }

    :root{
      --text:#ffffff; --bg:#000000;
      --z1:#3a3a3a; --z2:#1e3a8a; --z3:#166534; --z4:#7c3aed; --z5:#b91c1c;
      --font-nick:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-pct:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      --font-metric:"Montserrat-Thin",system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;

      --topbar-h: 60px;
      --phase-color: #eab308;

      /* grosor de la barra de zona */
      --zonebar-h: 14px;

      /* l√≠nea separadora */
      --zonebar-sep-color: #000000;
      --zonebar-sep-h: 2px;

      /* m√°rgenes laterales del contenido central */
      --inner-side-gap: 6%;

      /* ============================================================
         üîß AJUSTES MANUALES (CASO BASE 16 personas = grid 4x4)
         Cambia estos 4 valores para dejar el tama√±o base a tu gusto.
         ============================================================ */
      --base-nick-16:   56px;  /* nombre (arriba) */
      --base-pct-16:    56px;  /* % grande (centro) */
      --base-metric-16: 30px;  /* m√©tricas (abajo) */
      --base-icon-16:   30px;  /* iconos m√©tricas */

      /* Factor de escala din√°mico (JS lo actualiza autom√°ticamente) */
      --text-scale: 1;
    }

    *{box-sizing:border-box}
    html,body{
      margin:0;height:100%;width:100%;
      background:var(--bg);color:var(--text);
      font-family:var(--font-metric);
      overflow:hidden;
    }

    /* ======= TOPBAR ESTABLE (3 columnas): Izquierda | Logo | Derecha ======= */
    header.topbar{
      position:fixed; inset:0 0 auto 0; height:var(--topbar-h);
      display:grid;
      grid-template-columns: minmax(0,1fr) auto minmax(0,1fr);
      align-items:center; column-gap: 12px;
      padding: 0 12px 0 16px;
      z-index:20;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    /* Capas: contenido base y overlay */
    .topbar .left, .topbar .center, .topbar .right { position:relative; z-index:1; }

    /* Capa overlay que cubre todo el topbar sin afectar layout */
    .topbar .overlay {
      position:absolute; inset:0;
      pointer-events:none; /* no interfiere con clicks */
      z-index:2; /* por encima del contenido base */
    }

    /* Tipograf√≠a unificada */
    .clock, .phase, .timer{
      font-family:"StretchPro",ui-sans-serif,system-ui,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;
      font-weight:900; line-height:1; letter-spacing:.02em; white-space:nowrap;
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      font-variant-numeric:tabular-nums;
      font-size: calc(var(--topbar-h) * 0.8);
    }
    .phase, .timer { color: var(--phase-color); }
    .clock { color:#fff; }

    /* Izquierda: timer visible y estable */
    .left{ display:flex; align-items:center; gap:12px; min-width:0; height:100%; }
    .timer{ width:6ch; text-align:left; }

    /* Centro: logo fijo en el eje */
    .center{ display:flex; align-items:center; justify-content:center; }
    .logo-img { display:block; height: calc(var(--topbar-h) * 0.5); max-width: 34vw; object-fit: contain; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }

    /* Derecha: reloj */
    .right{ justify-self:end; }

    /* ===== Label (phase) superpuesto centrado en la MITAD IZQUIERDA del topbar ===== */
    .phase{
      position:absolute;
      /* Centro geom√©trico de la mitad izquierda => 25% del ancho total */
      left:25%; top:50%; transform:translate(-50%, -50%);
      max-width:50vw; /* por seguridad, no crezca m√°s de la mitad */
      text-align:center; overflow:hidden; text-overflow:ellipsis;
      pointer-events:none;
    }

    .invisible{ opacity: 0; }

    /* ====== layout base ====== */
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-metric);
    }

    .wrap {
      flex: 1;
      width: 100%;
      height: calc(100vh - var(--topbar-h));
      margin-top: var(--topbar-h);      /* ‚úÖ desplaza bajo el header fijo */
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    .grid {
      display: grid;
      width: 100%;
      height: 100%;
      gap: 14px;
      align-content: stretch;
      align-items: stretch;
      justify-content: stretch;
      transition: all .3s ease;
      /* ‚ùå quitar: padding-top: var(--topbar-h); */
    }

    /* ============================================================
       Card. Mantenemos container-type por si luego quieres cqmin,
       pero los tama√±os ahora vienen del factor --text-scale.
       ============================================================ */
    .card{
      position:relative;border-radius:16px;padding:16px;
      box-shadow:0 10px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      transition:opacity .6s ease, transform .3s ease, box-shadow .3s ease;
      container-type:size; color:#fff;
    }
    .card:active{transform:scale(.995)}
    .z1{background:var(--z1)}
    .z2{background:linear-gradient(135deg,#1e3a8a,#1f4bb5)}
    .z3{background:linear-gradient(135deg,#166534,#1c7a41)}
    .z4{background:linear-gradient(135deg,#7c3aed,#9333ea)}
    .z5{background:linear-gradient(135deg,#b91c1c,#ef4444)}

    /* Barra de zona superior */
    .zonebar { position:absolute; inset:0 0 auto 0; height: var(--zonebar-h); width:100%; display:block; border-top-left-radius:16px; border-top-right-radius:16px; background:#000; opacity:1; z-index:3; pointer-events:none; }
    .zonebar::after { content:""; position:absolute; bottom:-var(--zonebar-sep-h); left:0; width:100%; height:var(--zonebar-sep-h); background: var(--zonebar-sep-color); border-bottom-left-radius:16px; border-bottom-right-radius:16px; z-index:4; }
    .zonebar.hidden { display:none; }

    /* ====== Tama√±os de texto/√≠conos guiados por --text-scale ====== */
    .nick {
      position:absolute; top:10px; left:50%; transform:translateX(-50%);
      font-family:var(--font-nick); font-weight:800; letter-spacing:.02em;
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      text-align:center;
      white-space: nowrap;
      max-width: 92cqw;

      /* base + l√≠mite normal */
      font-size: calc(var(--base-nick-16) * var(--text-scale));

      /* üî• magia: si no cabe, se reduce autom√°ticamente */
      text-wrap: balance;
      font-size: clamp(
        10px,                                   /* nunca m√°s peque√±o que esto */
        calc(var(--base-nick-16) * var(--text-scale)), /* tama√±o normal */
        20cqw                                   /* tope m√°ximo por ancho */
      );
    }

    .pct{
      font-family:var(--font-pct);
      font-weight:900; line-height:1;
      text-shadow:0 4px 10px rgba(0,0,0,.35);
      text-align:center; font-variant-numeric: tabular-nums;

      font-size: min(
        calc(var(--base-pct-16) * var(--text-scale)),
        30cqw,
        22cqh
      );
    }

    .metric{
      display:flex; align-items:center; gap:8px;
      font-family:var(--font-metric); font-weight:800;
      text-shadow:0 1px 2px rgba(0,0,0,.25);
      white-space:nowrap;
      line-height: 1; /* ayuda a no ‚Äúempujar‚Äù verticalmente */
      font-size: min(
        calc(var(--base-metric-16) * var(--text-scale)),
        8cqw,
        8cqh
      );
    }

    /* Icono exactamente del tama√±o del texto */
    .metric .icon{
      display:inline-flex;
      width: 1em;
      height: 1em;
    }
    .metric .icon svg{ width:100%; height:100%; fill:currentColor; }

    /* Slots inferiores: ancho fijo + ellipsis real */
    .hr, .kcal, .moov{
      position:absolute; bottom:10px;
      display: block;            /* necesario para ellipsis */
      width: 30cqw;              /* ancho fijo por slot (‚âà1/3 card) */
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .hr   { left:12px;  text-align:left; }
    .kcal { left:50%; transform:translateX(-50%); text-align:center; width:34cqw; }
    .moov { right:12px; text-align:right; }

    .pct.summary-host{display:flex;align-items:center;justify-content:center;padding:0 var(--inner-side-gap);}
    .summarybar{ box-shadow: inset 0 2px 8px rgba(0,0,0,.35), 0 10px 24px rgba(0,0,0,.25); border-radius: 10px; width:100%; height:60%; }

    .empty{color:#9aa3b2;text-align:center;padding:24px;border:1px dashed #2c3350;border-radius:12px}
    @media (prefers-reduced-motion: reduce){.card,.grid{transition:none}}
  </style>
</head>
<body>

  <header class="topbar">
    <!-- Capa base: grid estable -->
    <div class="left">
      <div id="phaseTimer" class="timer invisible">00:00</div>
    </div>
    <div class="center">
      <img src="/static/logo_wemoov.png" alt="WeMoov" class="logo-img" />
    </div>
    <div class="right">
      <div id="clock" class="clock">--:--</div>
    </div>

    <!-- Capa overlay: no altera el layout -->
    <div class="overlay">
      <div id="phaseText" class="phase"></div>
    </div>
  </header>

  <div class="wrap"><div class="grid" id="grid"></div></div>

  <script>
    // ====== Config desde backend (unificado) ======
    let FADE_DURATION_MS = 60000;
    let LIVE_RECENT_MS = 5000;

    // ====== Resumen post-sesi√≥n ======
    let SUMMARY_MS = 15000;          // se sobreescribe desde /live/config
    let SUMMARY_MODE = false;        // bloquea reconcile() y muestra tarjetas de resumen
    let SUMMARY_TIMER = null;        // timeout para salir del modo resumen
    let SUMMARY_LOADING = false;     // reentrada protegida
    let LAST_SUMMARY_ETAG = null;    // versi√≥n del √∫ltimo resumen pintado
    const summaryBars = new Map();   // dev -> canvas del relieve

    (async () => {
      try {
        const r = await fetch('/live/config', { cache: 'no-store' });
        if (r.ok) {
          const cfg = await r.json();
          if (cfg && typeof cfg.fade_ms === 'number') FADE_DURATION_MS = cfg.fade_ms;
          if (cfg && typeof cfg.recent_ms === 'number') LIVE_RECENT_MS = cfg.recent_ms;
          if (cfg && typeof cfg.summary_ms === 'number') SUMMARY_MS = cfg.summary_ms; // ‚¨ÖÔ∏è nuevo
        }
      } catch {}
    })();

    // ====== Reloj cabecera (HH:MM, sin segundos) ======
    const clockEl = document.getElementById('clock');
    function updateClock(){
      const n = new Date();
      const hh = String(n.getHours()).padStart(2,'0');
      const mm = String(n.getMinutes()).padStart(2,'0');
      clockEl.textContent = `${hh}:${mm}`;
      // Programar la pr√≥xima actualizaci√≥n justo al inicio del siguiente minuto
      const msToNextMinute = (60 - n.getSeconds()) * 1000 - n.getMilliseconds();
      clearTimeout(updateClock._t);
      updateClock._t = setTimeout(updateClock, Math.max(0, msToNextMinute));
    }
    updateClock();

    // ====== Estado sesi√≥n ======
    const phaseEl = document.getElementById('phaseText');
    const timerEl = document.getElementById('phaseTimer');
    let SESSION_ACTIVE = false;
    let ZONELINE_TIMER = null;

    // Zona timeline params
    const ZONELINE_BUCKET_MS  = 5000;      // 5s
    const ZONELINE_WINDOW_MS  = 3600000;   // 1h (el backend limitar√° por KEEP_MS)
    const ZONELINE_REFRESH_MS = 10000;     // 10s

    function fmtMMSS(sec){ sec=Math.max(0,Math.floor(sec)); return `${String(Math.floor(sec/60)).padStart(2,'0')}:${String(sec%60).padStart(2,'0')}`; }
    function setPhaseColor(hex){ document.documentElement.style.setProperty('--phase-color', hex||'#eab308'); }

    function ensureZoneLineTimer(on){
      if (on && !ZONELINE_TIMER){ ZONELINE_TIMER = setInterval(refreshAllZoneBars, ZONELINE_REFRESH_MS); }
      if (!on && ZONELINE_TIMER){ clearInterval(ZONELINE_TIMER); ZONELINE_TIMER = null; }
    }

    function clearCanvas(cnv){
      const ctx = cnv.getContext('2d');
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = cnv.clientWidth  || cnv.parentElement?.clientWidth || 300;
      const heightCSS = cnv.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      cnv.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      cnv.height = Math.max(1, Math.floor(heightCSS * dpr));
      ctx.clearRect(0, 0, cnv.width, cnv.height);
    }

    function setZoneBarsVisible(on){
      for (const [, cnv] of zoneBars.entries()){
        if (on){ cnv.classList.remove('hidden'); drawZoneBarForDev(cnv.dataset.dev); }
        else { clearCanvas(cnv); cnv.classList.add('hidden'); }
      }
    }

    // ====== Modo Resumen (solo /live/summary/persisted con devices) ======
    function renderReliefBar(canvas, timeline, bucket_ms){
      if (!Array.isArray(timeline) || timeline.length === 0) return;
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth || 420;
      const heightCSS = canvas.clientHeight || Math.max(120, (canvas.parentElement?.clientHeight || 200) * 0.6);
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const firstT = timeline[0].t;
      const lastT  = (timeline[timeline.length - 1].t) + (bucket_ms || 1);
      const span   = Math.max(bucket_ms || 1, lastT - firstT);
      const toX = (t) => { const p = (t - firstT) / span; return Math.max(0, Math.min(canvas.width, Math.round(p * canvas.width))); };
      for (const b of timeline){
        const t0 = b.t, t1 = t0 + bucket_ms;
        const x0 = toX(t0), x1 = toX(t1);
        if (x1 <= 0 || x0 >= canvas.width) continue;
        const w = Math.max(1, x1 - x0);
        const frac = Math.max(0, Math.min(1, Number(b.frac) || 0));
        const h = Math.round(frac * canvas.height);
        const y = canvas.height - h;
        const z = b.zone_mode || 'Z1';
        ctx.fillStyle = zoneColor(z);
        ctx.fillRect(x0, y, w, h);
      }
    }

    function buildSummaryCard(dev, apodo, metrics, timeline, bucket_ms){
      const d = { dev, user: { apodo }, hr: null, metrics: { hr_max: null, zone: 'Z1', kcal: metrics?.kcal ?? null, points: metrics?.points ?? null } };
      const card = buildCard(d);
      const zc = zoneBars.get(dev); if (zc){ zc.classList.add('hidden'); clearCanvas(zc); }
      const pctEl = card.querySelector('.pct'); if (pctEl){ pctEl.textContent = ''; }
      const pctAvg = Number(metrics?.pct_avg ?? 0);
      const hrEl = card.querySelector(`#hr-${dev}`); if (hrEl){ hrEl.textContent = `${Math.round(pctAvg)}%`; }
      const relief = document.createElement('canvas');
      relief.className = 'summarybar';
      const pctHost = card.querySelector('.pct');
      if (pctHost){ pctHost.textContent = ''; pctHost.classList.add('summary-host'); pctHost.appendChild(relief); }
      else { relief.style.width = '100%'; relief.style.height = '60%'; card.appendChild(relief); }
      summaryBars.set(dev, relief);
      relief._summaryPayload = { timeline: Array.isArray(timeline) ? timeline : [], bucket_ms: bucket_ms || 5000 };
      renderReliefBar(relief, relief._summaryPayload.timeline, relief._summaryPayload.bucket_ms);
      return card;
    }

    function redrawAllSummaryBars(){
      for (const [dev, cnv] of summaryBars.entries()){
        const data = cnv._summaryPayload;
        if (data){ renderReliefBar(cnv, data.timeline || [], data.bucket_ms || 5000); }
      }
    }

    // ====== helpers fetch resumen (robusto, solo /live/summary/persisted) ======
    async function getPersistedSummary(etag) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), 8000); // timeout duro 8s
      try {
        const headers = {};
        if (etag) headers['If-None-Match'] = etag;
        const r = await fetch('/live/summary/persisted', { cache: 'no-store', headers, signal: ctrl.signal });
        clearTimeout(t);

        if (r.status === 204) {
          const ra = Number(r.headers.get('Retry-After') || 2);
          return { kind: 'pending', retryAfter: Number.isFinite(ra) ? ra : 2 };
        }
        if (r.status === 304) {
          return { kind: 'not_modified' };
        }
        if (r.ok) {
          const data = await r.json();
          let newETag = (r.headers.get('ETag') || '').replaceAll('"', '').trim() || null;
          return { kind: 'ok', data, etag: newETag };
        }
        return { kind: 'pending', retryAfter: 2 };
      } catch {
        clearTimeout(t);
        return { kind: 'pending', retryAfter: 2 };
      }
    }

    // ====== Modo Resumen ‚Äî SOLO /persisted, con salidas garantizadas ======
    async function startSummaryMode(){
      if (SUMMARY_MODE || SUMMARY_LOADING) return;
      SUMMARY_MODE = true;
      SUMMARY_LOADING = true;

      // reset visual/estado
      grid.innerHTML = '';
      cards.clear(); lastTs.clear(); lastBeatAt.clear();
      zoneBars.clear(); zoneBarState.clear(); summaryBars.clear();

      // placeholder
      const holder = document.createElement('div');
      holder.className = 'card z1';
      holder.style.cssText = 'display:flex;align-items:center;justify-content:center;height:240px;opacity:1';
      holder.textContent = 'Generando resumen‚Ä¶';
      grid.appendChild(holder);
      layoutForCount(1);

      const T0 = Date.now();
      const MAX_WAIT = 12000; // 12s
      let payload = null;
      let etag = LAST_SUMMARY_ETAG || null;

      while ((Date.now() - T0) < MAX_WAIT && !SESSION_ACTIVE) {
        const res = await getPersistedSummary(etag);

        if (res.kind === 'ok') {
          payload = res.data;
          if (res.etag) etag = res.etag;
          break;
        }

        if (res.kind === 'not_modified') {
          // Si no hay copia previa (app reci√©n abierta), fuerza un fetch sin ETag
          if (!payload) {
            const res2 = await getPersistedSummary(null);
            if (res2.kind === 'ok') {
              payload = res2.data;
              if (res2.etag) etag = res2.etag;
            }
          }
          break;
        }

        // pending -> respeta Retry-After
        const waitSec = Math.max(1, res.retryAfter || 2);
        await new Promise(r => setTimeout(r, waitSec * 1000));
      }

      // si volvi√≥ a arrancar sesi√≥n, aborta limpio
      if (SESSION_ACTIVE) {
        SUMMARY_LOADING = false;
        SUMMARY_MODE = false;
        grid.innerHTML = '';
        return;
      }

      // ====== salidas garantizadas ======
      if (!payload) {
        holder.textContent = 'Resumen no disponible a√∫n‚Ä¶';
        SUMMARY_LOADING = false;
        setTimeout(() => { if (!SESSION_ACTIVE) startSummaryMode(); }, 3000); // reintento suave
        return;
      }

      if (!Array.isArray(payload.devices) || payload.devices.length === 0){
        holder.textContent = 'Resumen vac√≠o.';
        SUMMARY_LOADING = false;
        return;
      }

      // pintar resumen
      grid.innerHTML = '';
      cards.clear(); summaryBars.clear();

      const bucket = (typeof payload.bucket_ms === 'number') ? payload.bucket_ms : 5000;
      const devices = [...payload.devices].sort((a,b)=>{
        const da = (typeof a.dev === 'number') ? a.dev : String(a.dev);
        const db = (typeof b.dev === 'number') ? b.dev : String(b.dev);
        return (da>db)-(da<db);
      });

      try {
        for (const devRow of devices){
          const dev = devRow.dev;
          const apodo = (devRow.user && devRow.user.apodo) || `ID ${dev}`;
          const m = devRow.metrics || {};
          const tl = Array.isArray(devRow.timeline) ? devRow.timeline : [];
          const card = buildSummaryCard(dev, apodo, m, tl, bucket);
          grid.appendChild(card);
          cards.set(dev, { el: card, fadeStart: null });
        }
      } catch (e) {
        console.error('render summary failed:', e);
        holder.textContent = 'Error renderizando el resumen';
        SUMMARY_LOADING = false;
        return;
      }

      layoutForCount(cards.size);
      if (etag) LAST_SUMMARY_ETAG = etag;
      SUMMARY_LOADING = false;
      stopSummaryMode(SUMMARY_MS);
    }


    function stopSummaryMode(delayMs){
      if (SUMMARY_TIMER) clearTimeout(SUMMARY_TIMER);
      SUMMARY_TIMER = setTimeout(() => {
        SUMMARY_MODE = false;
        grid.innerHTML = '';
        cards.clear(); lastTs.clear(); lastBeatAt.clear();
        zoneBars.clear(); zoneBarState.clear();
        summaryBars.clear();
      }, Math.max(0, Number(delayMs) || 0));
    }

    // ========= POLL de estado de sesi√≥n =========
    async function pollSession(){
      try{
        const res = await fetch('/control/status', { cache:'no-store' });
        const s = await res.json();
        const wasActive = SESSION_ACTIVE;
        SESSION_ACTIVE = !!s.active;

        if (!s.active && s.show_countdown){
          document.documentElement.style.setProperty('--phase-color', '#ffffff');
          timerEl.textContent = fmtMMSS(s.countdown_s || 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(false);
          setZoneBarsVisible(false);
          return;
        }

        if (s.active){
          setPhaseColor(s.phase_color||'#eab308');
          phaseEl.textContent = s.phase_key || 'Sesi√≥n';
          timerEl.textContent = fmtMMSS(s.phase_remaining_s ?? 0);
          timerEl.classList.remove('invisible');
          ensureZoneLineTimer(true);
          if (!wasActive && SESSION_ACTIVE){
            setZoneBarsVisible(true);
            refreshAllZoneBars();
            if (SUMMARY_MODE) stopSummaryMode(0);
          }
          return;
        }

        // ‚¨áÔ∏è Sin sesi√≥n
        setPhaseColor('#e7eaf3');
        phaseEl.textContent = '';
        timerEl.textContent = '00:00';
        timerEl.classList.add('invisible');
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);

        // Transici√≥n de activa -> inactiva: arrancar resumen
        if (wasActive && !SESSION_ACTIVE){ startSummaryMode(); }
      }catch(e){
        ensureZoneLineTimer(false);
        setZoneBarsVisible(false);
      }
    }
    setInterval(pollSession,1000); pollSession();

    // ====== HR Grid ======
    const POLL_MS = 1000, IDLE_POLL_MS = 5000, FETCH_TIMEOUT_MS = 8000, MAX_ERROR_BACKOFF_MS = 6000;
    const grid = document.getElementById('grid');
    const lastTs = new Map(), cards = new Map();
    const lastBeatAt = new Map();
    const zoneBars = new Map();
    const zoneBarState = new Map();
    let nextTimer=null, errorBackoff=POLL_MS, abortCtrl=null, useSSE=false, es=null;

    const zoneClass = z => ({ Z1:'z1', Z2:'z2', Z3:'z3', Z4:'z4', Z5:'z5' })[z] || 'z1';
    const zoneColor = z => ({
      Z1:getComputedStyle(document.documentElement).getPropertyValue('--z1').trim()||'#3a3a3a',
      Z2:getComputedStyle(document.documentElement).getPropertyValue('--z2').trim()||'#1e3a8a',
      Z3:getComputedStyle(document.documentElement).getPropertyValue('--z3').trim()||'#166534',
      Z4:getComputedStyle(document.documentElement).getPropertyValue('--z4').trim()||'#7c3aed',
      Z5:getComputedStyle(document.documentElement).getPropertyValue('--z5').trim()||'#b91c1c'
    })[z] || '#3a3a3a';
    const pctFrom = (hr, hrmax) => (typeof hr==='number' && typeof hrmax==='number' && hrmax>0)
      ? Math.max(0, Math.min(100, Math.floor((hr*100)/hrmax))) : null;

    /* ============================================================
       üìê C√°lculo de escala de texto
       - Toma como referencia el layout 4x4 (16 personas).
       - Escala por la proporci√≥n del lado menor de la card.
       ============================================================ */
    function computeCardMinDim(cols, rows){
      const cs = getComputedStyle(grid);
      const rowGap = parseFloat(cs.rowGap || cs.gap) || 0;
      const colGap = parseFloat(cs.columnGap || cs.gap) || 0;

      const gridW = grid.clientWidth;
      const gridH = grid.clientHeight;

      const widthPerCard  = Math.max(0, (gridW - (cols - 1) * colGap) / cols);
      const heightPerCard = Math.max(0, (gridH - (rows - 1) * rowGap) / rows);
      return Math.min(widthPerCard, heightPerCard);
    }

    // "Caso base" te√≥rico 4x4 (independiente del layout actual)
    function getBaseMinDimFor16(){
      return computeCardMinDim(4, 4);
    }

    // Lee cols/rows aplicados en el grid (repeat(n, 1fr))
    function getCurrentMinDim(){
      const cols = (grid.style.gridTemplateColumns.match(/repeat\((\d+)/) || [ , 1 ])[1]*1 || 1;
      const rows = (grid.style.gridTemplateRows.match(/repeat\((\d+)/) || [ , 1 ])[1]*1 || 1;
      return computeCardMinDim(cols, rows);
    }

    function updateTextScale(){
      const baseMin = getBaseMinDimFor16();   // referencia 4x4
      const curMin  = getCurrentMinDim();     // tama√±o actual
      let scale = 1;
      if (baseMin > 0) scale = curMin / baseMin;

      // (Opcional) Limitar rango si quieres evitar extremos:
      // scale = Math.max(0.7, Math.min(scale, 2));

      document.documentElement.style.setProperty('--text-scale', String(scale));
    }

    function layoutForCount(n){
      if (n <= 0){
        grid.style.gridTemplateColumns = '';
        grid.style.gridTemplateRows = '';
        grid.style.justifyContent = 'center';
        updateTextScale();
        return;
      }

      let cols, rows;

      if (n <= 2){
        cols = n; rows = 1;
      } else if (n <= 4){
        cols = 2; rows = 2;       // 3 o 4 -> 2x2
      } else if (n <= 6){
        cols = 3; rows = 2;       // 5 o 6 -> 3x2
      } else if (n <= 8){
        cols = 4; rows = 2;
      } else if (n === 9){
        cols = 3; rows = 3;       // excepci√≥n 9 -> 3x3
      } else if (n <= 12){
        cols = 4; rows = 3;
      } else {
        cols = 4; rows = 4;       // 13+ -> 4x4
      }

      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows    = `repeat(${rows}, 1fr)`;
      grid.style.justifyContent      = 'stretch';
      grid.style.alignContent        = 'stretch';
      grid.style.alignItems          = 'stretch';

      const style = getComputedStyle(grid);
      const gap   = parseFloat(style.gap) || 0;
      const h     = grid.clientHeight;
      const heightPerCard = Math.max(0, (h - (rows - 1) * gap) / rows);

      grid.querySelectorAll('.card').forEach(c => {
        c.style.height = `${heightPerCard}px`;
      });

      // üîë Recalcular la escala de texto tras aplicar el layout
      updateTextScale();
    }


    function buildCard(d){
      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      const hr=(typeof d.hr==='number')?d.hr:null;
      const m=d.metrics||{}, hrmax=m.hr_max??null, zone=m.zone||'Z1';
      const pct=pctFrom(hr,hrmax);
      const kcal=(typeof m.kcal==='number')?m.kcal:null;
      const pts =(typeof m.points==='number')?m.points:null;

      const card=document.createElement('div');
      card.className=`card ${zoneClass(zone)}`; card.style.opacity='1';

      const zc = document.createElement('canvas');
      zc.className = 'zonebar';
      zc.dataset.dev = d.dev;
      if (!SESSION_ACTIVE) zc.classList.add('hidden');
      card.appendChild(zc);
      zoneBars.set(d.dev, zc);

      const nick = Object.assign(document.createElement('div'), { className:'nick', textContent:apodo });
      const pctEl= Object.assign(document.createElement('div'), { className:'pct',  textContent:(pct==null?'--%':`${pct}%`) });

      const hrWrap=Object.assign(document.createElement('div'), { className:'metric hr' });
      const hrEl  =Object.assign(document.createElement('span'), { id:`hr-${d.dev}`, textContent:(hr==null?'--':`${hr}`) });
      const heart =document.createElement('span'); heart.className='icon';
      heart.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 21s-5.052-3.247-8.106-6.3C1.84 12.646 1 10.97 1 9.2 1 6.88 2.88 5 5.2 5c1.36 0 2.656.56 3.6 1.56L12 9.04l3.2-2.48C16.144 5.56 17.44 5 18.8 5 21.12 5 23 6.88 23 9.2c0 1.77-.84 3.446-2.894 5.5C17.052 17.753 12 21 12 21z"/></svg>`;
      hrWrap.append(hrEl, heart);

      const kWrap =Object.assign(document.createElement('div'), { className:'metric kcal' });
      const kcalEl=Object.assign(document.createElement('span'), { id:`kcal-${d.dev}`, textContent:(kcal==null?'--':(Math.round(kcal*10)/10).toFixed(0)) });
      const flame =document.createElement('span'); flame.className='icon';
      flame.innerHTML=`<svg viewBox="0 0 24 24"><path d="M12 2C9.243 5.026 8 7.91 8 10.5A4.5 4.5 0 0 0 12.5 15c2.4 0 4.5-2 4.5-4.5 0-2.59-1.243-5.474-4-8.5zM12 22c5.523 0 10-4.477 10-10 0-4.004-2.383-7.738-6-9.334.666 1.944 1 3.994 1 6.334a6 6 0 1 1-12 0c0-2.34.334-4.39 1-6.334C4.383 4.262 2 7.996 2 12c0 5.523 4.477 10 10 10z"/></svg>`;
      kWrap.append(kcalEl, flame);

      const mWrap =Object.assign(document.createElement('div'), { className:'metric moov' });
      const moovEl=Object.assign(document.createElement('span'), { id:`moov-${d.dev}`, textContent:(pts==null?'--':(Math.round(pts*10)/10).toFixed(0)) });
      const mlogo =document.createElement('span'); mlogo.className='icon';
      mlogo.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"></circle><path d="M7 16V8h2.6l2.4 4 2.4-4H17v8h-2V11.7l-2 3.3h-2L9 11.7V16H7z" fill="var(--bg)"></path></svg>`;
      mWrap.append(moovEl, mlogo);

      card.append(nick, pctEl, hrWrap, kWrap, mWrap);

      if (SESSION_ACTIVE) drawZoneBarForDev(d.dev);
      return card;
    }

    function updateCardContent(card, d){
      const m=d.metrics||{}, zone=m.zone||'Z1';
      card.className = `card ${zoneClass(zone)}`;

      const user=d.user||{}, apodo=user.apodo||`ID ${d.dev}`;
      card.querySelector('.nick').textContent = apodo;

      const hr=(typeof d.hr==='number')?d.hr:null;
      const hrmax=m.hr_max??null;
      const pct=pctFrom(hr,hrmax);
      const pctEl = card.querySelector('.pct'); if (pctEl) pctEl.textContent = (pct==null?'--%':`${pct}%`);
      const hrEl = card.querySelector(`#hr-${d.dev}`); if (hrEl) hrEl.textContent = (hr==null?'--':`${hr}`);

      const kcal = (typeof m.kcal==='number') ? m.kcal : null;
      const pts  = (typeof m.points==='number') ? m.points : null;
      const kcalEl = card.querySelector(`#kcal-${d.dev}`);
      const ptsEl  = card.querySelector(`#moov-${d.dev}`);
      if (kcalEl) kcalEl.textContent = (kcal==null ? '--' : (Math.round(kcal*10)/10).toFixed(0));
      if (ptsEl)  ptsEl.textContent  = (pts ==null ? '--' : (Math.round(pts *10)/10).toFixed(0));
    }

    function reconcile(list){
      if (SUMMARY_MODE) return; // no tocar durante resumen

      const now = Date.now();
      const arr = Array.isArray(list) ? list : [];
      const presentIds = new Set(arr.map(d => d.dev));

      // crear/actualizar
      arr.forEach(d => {
        let entry = cards.get(d.dev);
        if (!entry){
          const el = buildCard(d);
          cards.set(d.dev, { el, fadeStart: null });
          grid.append(el);
        }else{
          updateCardContent(entry.el, d);
          if (entry.fadeStart !== null){ entry.fadeStart = null; entry.el.style.opacity = '1'; }
        }
      });

      // desvanecer desaparecidos
      for (const [dev, entry] of Array.from(cards.entries())){
        if (!presentIds.has(dev)){
          if (entry.fadeStart == null){ entry.fadeStart = now; }
          const p = Math.min(1, (now - entry.fadeStart) / FADE_DURATION_MS);
          entry.el.style.opacity = String(1 - p);
          if (p >= 1){
            try { grid.removeChild(entry.el); } catch {}
            cards.delete(dev); lastTs.delete(dev);
            zoneBars.delete(dev); zoneBarState.delete(dev);
          }
        }
      }

      layoutForCount(cards.size);

      // guardar ts
      arr.forEach(d=>{ const ts=d.ts||'', prev=lastTs.get(d.dev); if (ts && ts!==prev) lastTs.set(d.dev, ts); });

      if (SESSION_ACTIVE){ arr.forEach(d => drawZoneBarForDev(d.dev)); }
    }

    function scheduleNext(ms){ if (nextTimer) clearTimeout(nextTimer); nextTimer = setTimeout(tick, ms); }

    // ====== Polling fallback ======
    const POLL_URL = '/live?limit=16';
    async function fetchOnceAndRender() {
      if (document.hidden){ scheduleNext(IDLE_POLL_MS); return; }
      if (abortCtrl) abortCtrl.abort();
      abortCtrl = new AbortController();
      const timeout = setTimeout(()=>abortCtrl.abort(), FETCH_TIMEOUT_MS);
      try{
        const res  = await fetch(POLL_URL, { cache:'no-store', headers:{'Cache-Control':'no-store'}, signal:abortCtrl.signal });
        const list = await res.json();
        clearTimeout(timeout);
        reconcile(list);
        errorBackoff = POLL_MS;
        scheduleNext((list && list.length) ? POLL_MS : IDLE_POLL_MS);
      }catch(e){
        clearTimeout(timeout);
        errorBackoff = Math.min(MAX_ERROR_BACKOFF_MS, Math.max(POLL_MS, Math.floor((errorBackoff||POLL_MS)*2)));
        scheduleNext(errorBackoff);
      }
    }
    function tick(){ if (!useSSE) fetchOnceAndRender(); }

    // ====== SSE con fallback ======
    function startSSE() {
      try {
        es = new EventSource('/live/stream');
        useSSE = true;
        es.onmessage = (e) => { const list = JSON.parse(e.data); reconcile(list); };
        es.onerror = () => { if (es) { es.close(); es = null; } useSSE = false; tick(); };
      } catch (e) { useSSE = false; tick(); }
    }

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden){
        if (nextTimer) clearTimeout(nextTimer);
        if (!useSSE && !es) tick();
        if (SUMMARY_MODE){ redrawAllSummaryBars(); }
        else if (SESSION_ACTIVE){ refreshAllZoneBars(); }
        // refrescar reloj al volver de background
        updateClock();
        // Recalcular escala tras posibles cambios de viewport
        updateTextScale();
      }
    });
    window.addEventListener('resize', () => {
      layoutForCount(cards.size);
      if (SUMMARY_MODE){ redrawAllSummaryBars(); }
      else if (SESSION_ACTIVE) { refreshAllZoneBars(); }
      updateTextScale();
    });

    // ====== Zona timeline helpers (ANCLADO AL INICIO) ======
    async function drawZoneBarForDev(dev){
      const cardEntry = cards.get(dev); if (!cardEntry) return;
      const canvas = zoneBars.get(dev); if (!canvas) return;
      try{
        const url = `/live/zone_timeline?dev=${encodeURIComponent(dev)}&bucket_ms=${ZONELINE_BUCKET_MS}&window_ms=${ZONELINE_WINDOW_MS}`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        renderZoneBar(canvas, data);
      }catch{}
    }

    function renderZoneBar(canvas, payload) {
      if (!payload || !Array.isArray(payload.timeline) || payload.timeline.length === 0) return;
      const { bucket_ms, timeline } = payload;
      const firstT = timeline[0].t;
      const lastT  = timeline[timeline.length - 1].t + bucket_ms;
      const span   = Math.max(bucket_ms || 1, lastT - firstT);
      const dpr = window.devicePixelRatio || 1;
      const widthCSS  = canvas.clientWidth  || canvas.parentElement.clientWidth  || 300;
      const heightCSS = canvas.clientHeight || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zonebar-h')) || 14;
      canvas.width  = Math.max(1, Math.floor(widthCSS  * dpr));
      canvas.height = Math.max(1, Math.floor(heightCSS * dpr));
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const toX = (t) => { const p = (t - firstT) / span; return Math.max(0, Math.min(canvas.width, p * canvas.width)); };
      const totalW = canvas.width;
      let prevRight = 0;
      for (let i = 0; i < timeline.length; i++) {
        const item = timeline[i];
        const t0 = item.t;
        const t1 = t0 + bucket_ms;
        const z  = item.zone_mode || 'Z1';
        const x0 = toX(t0);
        const x1 = toX(t1);
        const startX = Math.max(prevRight, Math.floor(x0));
        const segRight = Math.min(totalW, Math.ceil(x1));
        if (segRight > startX) {
          ctx.fillStyle = zoneColor(z);
          ctx.fillRect(startX, 0, segRight - startX + 1, canvas.height);
        }
        prevRight = segRight;
      }
      if (prevRight < totalW) { ctx.fillRect(totalW - 1, 0, 1, canvas.height); }
    }

    function refreshAllZoneBars(){
      if (!SESSION_ACTIVE) return;
      for (const dev of cards.keys()){ drawZoneBarForDev(dev); }
    }

    // ====== Arranque ======
    startSSE(); // SSE; si falla, polling har√° tick()
  </script>
</body>
</html>
